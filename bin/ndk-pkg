#!/bin/sh

# https://developer.android.google.cn/ndk/guides/other_build_systems
# https://clang.llvm.org/docs/CrossCompilation.html


_0=$0

unset CURRENT_SCRIPT_DIR
unset CURRENT_SCRIPT_FILENAME
unset CURRENT_SCRIPT_FILEPATH

CURRENT_SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd) || exit 1
CURRENT_SCRIPT_FILENAME=$(basename "$0")
CURRENT_SCRIPT_FILEPATH="$CURRENT_SCRIPT_DIR/$CURRENT_SCRIPT_FILENAME"


COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;34m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

print() {
    printf "%b" "$*"
}

echo() {
    print "$*\n"
}

info() {
    echo "$COLOR_PURPLE==>$COLOR_OFF $COLOR_GREEN$@$COLOR_OFF"
}

success() {
    print "${COLOR_GREEN}[âœ”] $*\n${COLOR_OFF}"
}

warn() {
    print "${COLOR_YELLOW}ðŸ”¥  $*\n${COLOR_OFF}" >&2
}

error() {
    print "${COLOR_RED}[âœ˜] $*\n${COLOR_OFF}" >&2
}

die() {
    print "${COLOR_RED}[âœ˜] $*\n${COLOR_OFF}" >&2
    exit 1
}

# check if file exists
# $1 FILEPATH
file_exists() {
    [ -n "$1" ] && [ -e "$1" ]
}

# check if command exists in filesystem
# $1 command name or path
command_exists_in_filesystem() {
    case $1 in
        '') return 1 ;;
        */*)
            case $(uname | tr A-Z a-z) in
                cygwin*)
                    case $1 in
                        /cygdrive/*/choco) executable "$1" ;;
                        /cygdrive/*) return 1 ;;
                        *) executable "$1" ;;
                    esac
                    ;;
                *) executable "$1" ;;
            esac
            ;;
        *)  command_exists_in_filesystem $(command -v "$1" || true)
    esac
}

executable() {
    file_exists "$1" && [ -x "$1" ]
}

die_if_file_is_not_exist() {
    file_exists "$1" || die "$1 is not exist."
}

die_if_not_executable() {
    executable "$1" || die "$1 is not executable."
}

step() {
    STEP_NUM=$(expr ${STEP_NUM-0} + 1)
    STEP_MESSAGE="$@"
    echo
    echo "${COLOR_PURPLE}=>> STEP ${STEP_NUM} : ${STEP_MESSAGE} ${COLOR_OFF}"
}

run() {
    info "$*"
    eval "$*"
}

list() {
    for item in $@
    do
        echo "$item"
    done
}

list_length() {
    echo $#
}

shiftn() {
    shift "$1" && shift && echo "$@"
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        unset SED_IN_PLACE_ACTION
        SED_IN_PLACE_ACTION="$1"
        shift
        # contains ' but not contains \'
        if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
            run gsed -i "\"$SED_IN_PLACE_ACTION\"" $@
        else
            run gsed -i "'$SED_IN_PLACE_ACTION'" $@
        fi
    elif command -v sed  > /dev/null ; then
        if sed -i 's/a/b/g' $(mktemp) 2> /dev/null ; then
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i "'$SED_IN_PLACE_ACTION'" $@
            fi
        else
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i '""' "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i '""' "'$SED_IN_PLACE_ACTION'" $@
            fi
        fi
    else
        die "please install sed utility."
    fi
}

getvalue() {
    if [ $# -eq 0 ] ; then
        cut -d= -f2
    else
        echo "$1" | cut -d= -f2
    fi
}

trim() {
    if [ $# -eq 0 ] ; then
        sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
    else
        if [ -n "$*" ] ; then
            echo "$*" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
        fi
    fi
}

tolower() {
    if [ $# -eq 0 ] ; then
        if command -v tr > /dev/null ; then
            tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            gawk '{print(tolower($0))}'
        else
            die "please install GNU CoreUtils or awk."
        fi
    else
        if [ -z "$*" ] ; then
            return 0
        fi
        if command -v tr > /dev/null ; then
            echo "$*" | tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            echo "$*" | awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            echo "$*" | gawk '{print(tolower($0))}'
        elif command -v python > /dev/null ; then
            python  -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python3 > /dev/null ; then
            python3 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python2 > /dev/null ; then
            python2 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v perl > /dev/null ; then
            perl -e 'print @ARGV[0],"\n"' "$1"
        elif command -v node > /dev/null ; then
            node -e 'console.log(process.argv[2].toLowerCase())' - "$*"
        else
            die "please install GNU CoreUtils or awk."
        fi
    fi
}

# https://stackoverflow.com/questions/45181115/portable-way-to-find-the-number-of-processors-cpus-in-a-shell-script
nproc() {
    case "$(uname)" in
        Darwin) sysctl -n machdep.cpu.thread_count ;;
        *BSD)   sysctl -n hw.ncpu ;;
        *)  if command nproc --version > /dev/null 2>&1 ; then
                command nproc
            elif test -f /proc/cpuinfo ; then
                grep -c processor /proc/cpuinfo
            else
                echo 4
            fi
    esac
}

own() {
    if command -v awk > /dev/null ; then
        ls -ld "$1" | awk '{print $3":"$4}'
    else
        ls -ld "$1" | cut -d ' ' -f4,6 | tr ' ' ':'
    fi
}

is_integer () {
    case "${1#[+-]}" in
        (*[!0123456789]*) return 1 ;;
        ('')              return 1 ;;
        (*)               return 0 ;;
    esac
}

format_unix_timestamp() {
   date -jf "%s" "$1" "$2" 2> /dev/null ||
   date -d      "@$1" "$2"
}

# }}}
##############################################################################
# {{{ md5sum

#examples:
# printf ss | md5sum
# cat FILE  | md5sum
# md5sum < FILE
md5sum() {
    if [ $# -eq 0 ] ; then
        if echo | command md5sum > /dev/null 2>&1 ; then
             command md5sum | cut -d ' ' -f1
        elif command -v openssl > /dev/null ; then
             openssl md5 | rev | cut -d ' ' -f1 | rev
        else
            return 1
        fi
    else
        if command -v openssl > /dev/null ; then
             openssl md5    "$1" | cut -d ' ' -f2
        elif echo | command md5sum > /dev/null 2>&1 ; then
             command md5sum "$1" | cut -d ' ' -f1
        else
            die "please install openssl or GNU CoreUtils."
        fi
    fi
}

# }}}
##############################################################################
# {{{ sha256sum

#examples:
# printf ss | sha256sum
# cat FILE  | sha256sum
# sha256sum < FILE
sha256sum() {
    if [ $# -eq 0 ] ; then
        if echo | command sha256sum > /dev/null 2>&1 ; then
             command sha256sum | cut -d ' ' -f1
        elif command -v openssl > /dev/null ; then
             openssl sha256 | rev | cut -d ' ' -f1 | rev
        else
            return 1
        fi
    else
        die_if_file_is_not_exist "$1"
        if command -v openssl > /dev/null ; then
             openssl sha256    "$1" | cut -d ' ' -f2
        elif echo | command sha256sum > /dev/null 2>&1 ; then
             command sha256sum "$1" | cut -d ' ' -f1
        else
            die "please install openssl or GNU CoreUtils."
        fi
    fi
}

# $1 FILEPATH
# $2 expect sha256sum
file_exists_and_sha256sum_matched() {
    die_if_file_is_not_exist "$1"
    if [ -z "$2" ] ; then
        die "please specify expected sha256sum."
    fi

    [ "$(sha256sum $1)" = "$2" ]
}

# $1 FILEPATH
# $2 expect sha256sum
die_if_sha256sum_mismatch() {
    file_exists_and_sha256sum_matched "$1" "$2" || die "sha256sum mismatch.\n    expect : $2\n    actual : $(sha256sum $1)"
}

# }}}
##############################################################################
# {{{ map

# $1 map_name
__map_name_ref() {
    printf "map_%s\n" "$(printf '%s' "$1" | md5sum)"
}

# $1 map_name
# $2 key
__map_key_ref() {
    printf "%s_key_%s\n" "$(__map_name_ref "$1")" "$(printf '%s' "$2" | md5sum)"
}

# $1 map_name
# $2 key
map_contains() {
    die_if_map_name_is_not_specified "$1"
    die_if_map_key__is_not_specified "$2"
    for item in $(eval echo \$$(__map_name_ref "$1"))
    do
        if [ "$item" = "$2" ] ; then
            return 0
        fi
    done
    return 1
}

# $1 map_name
# $2 key
# $3 value
map_set() {
    if ! map_contains "$1" "$2" ; then
        unset __MAP_NAME_REF__
        __MAP_NAME_REF__="$(__map_name_ref "$1")"
        __MAP_NAME_REF_VALUE__="$(eval echo \$$__MAP_NAME_REF__)"
        eval "$__MAP_NAME_REF__=\"$__MAP_NAME_REF_VALUE__ $2\""
    fi
    eval "$(__map_key_ref "$1" "$2")=$3"
}

# $1 map_name
# $2 key
# output: value
map_get() {
    die_if_map_name_is_not_specified "$1"
    die_if_map_key__is_not_specified "$2"
    eval echo "\$$(__map_key_ref "$1" "$2")"
}

# $1 map_name
# $2 key
# output: value
map_remove() {
    die_if_map_name_is_not_specified "$1"
    die_if_map_key__is_not_specified "$2"

    unset __MAP_NAME_REF__
    __MAP_NAME_REF__="$(__map_name_ref "$1")"

    unset __MAP_KEYS__
    __MAP_KEYS__="$(map_keys "$1")"

    unset $__MAP_NAME_REF__

    for item in $__MAP_KEYS__
    do
        if [ "$item" = "$2" ] ; then
            continue
        else
            eval "$__MAP_NAME_REF__='$(eval echo \$$__MAP_NAME_REF__) $item'"
        fi
    done
    eval "unset $(__map_key_ref "$1" "$2")"
}

# $1 map_name
map_clear() {
    die_if_map_name_is_not_specified "$1"

    unset __MAP_NAME_REF__
    __MAP_NAME_REF__="$(__map_name_ref "$1")"

    for item in $(eval echo "\$$__MAP_NAME_REF__")
    do
        eval "unset $(__map_key_ref "$1" "$item")"
    done
    eval "unset $__MAP_NAME_REF__"
}

# $1 map_name
# output: key list
map_keys() {
    die_if_map_name_is_not_specified "$1"
    eval echo "\$$(__map_name_ref "$1")"
}

# $1 map_name
# output: key list length
map_size() {
    die_if_map_name_is_not_specified "$1"
    list_length $(map_keys "$1")
}

# $1 map_name
die_if_map_name_is_not_specified() {
    if [ -z "$1" ] ; then
        die "please specify a map name."
    fi
}

# $1 key
die_if_map_key__is_not_specified() {
    if [ -z "$1" ] ; then
        die "please specify a map key."
    fi
}

# }}}
##############################################################################
# {{{ fetch

# fetch <URL> [--sha256=SHA256] <--output-path=PATH>
# fetch <URL> [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
# fetch <URL> [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
# fetch <URL> [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>
fetch() {
    unset FETCH_URL
    unset FETCH_SHA256
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_PATH
    unset FETCH_PIPE_TO_CMD

    if [ -z "$1" ] ; then
        die "fetch() please specify a url."
    else
        FETCH_URL="$1"
    fi

    shift

    while [ -n "$1" ]
    do
        case $1 in
            --sha256=*)
                FETCH_SHA256=$(getvalue "$1")
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    die "fetch() --output-dir argument's value must not be empty."
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    die "fetch() --output-name argument's value must not be empty."
                fi
                ;;
            --output-path=*)
                FETCH_OUTPUT_PATH=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_PATH" ] ; then
                    die "fetch() --output-path argument's value must not be empty."
                fi
                ;;
            --pipe=*)
                FETCH_PIPE_TO_CMD=$(getvalue "$1")
                if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                    die "fetch() --pipe=CMD argument's value must not be empty."
                fi
        esac
        shift
    done

    if [ -z "$FETCH_OUTPUT_PATH" ] ; then
        if [ -z "$FETCH_OUTPUT_DIR" ] && [ -z "$FETCH_OUTPUT_NAME" ] ; then
            FETCH_OUTPUT_PATH='-'
        else
            if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                FETCH_OUTPUT_DIR="$PWD"
            fi
            if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")
            fi
            FETCH_OUTPUT_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"
            if [ ! -d "$FETCH_OUTPUT_DIR" ] ; then
                run install -d "$FETCH_OUTPUT_DIR"
            fi
        fi
    elif [ "$FETCH_OUTPUT_PATH" = '-' ] ; then
        unset FETCH_OUTPUT_DIR
        unset FETCH_OUTPUT_NAME
    else
        FETCH_OUTPUT_DIR="$(dirname $FETCH_OUTPUT_PATH)"
        FETCH_OUTPUT_NAME="$(basename $FETCH_OUTPUT_PATH)"
        if [ ! -d "$FETCH_OUTPUT_DIR" ] ; then
            run install -d "$FETCH_OUTPUT_DIR"
        fi
    fi

    case $FETCH_URL in
        *.git)
            if [ -d "$FETCH_OUTPUT_PATH" ] ; then
                run cd  "$FETCH_OUTPUT_PATH" || return 1
                if      git rev-parse 2> /dev/null ; then
                    run git pull &&
                    run git submodule update --recursive
                else
                    run cd .. &&
                    run rm -rf "$FETCH_OUTPUT_NAME" &&
                    run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME"
                fi
            else
                if [ ! -d "$FETCH_OUTPUT_DIR" ] ; then
                    run install -d "$FETCH_OUTPUT_DIR" || return 1
                fi
                run cd "$FETCH_OUTPUT_DIR" || return 1
                run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME"
            fi
            ;;
        *)
            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -f "$FETCH_OUTPUT_PATH" ] ; then
                if [ -n "$FETCH_SHA256" ] ; then
                    if file_exists_and_sha256sum_matched "$FETCH_OUTPUT_PATH" "$FETCH_SHA256" ; then
                        success "$FETCH_OUTPUT_PATH already have been downloaded."
                        return 0
                    fi
                fi
                rm -f "$FETCH_OUTPUT_PATH"
            fi

            for FETCH_TOOL in curl wget http lynx aria2c axel
            do
                if command_exists_in_filesystem "$FETCH_TOOL" ; then
                    break
                else
                    unset FETCH_TOOL
                fi
            done

            if [ -z "$FETCH_TOOL" ] ; then
                handle_dependency required exe curl
                FETCH_TOOL=curl
            fi

            case $FETCH_TOOL in
                curl)
                    if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                        run "curl --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "curl --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URL' | $FETCH_PIPE_TO_CMD"
                    fi
                    ;;
                wget)
                    if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                        run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URL' | $FETCH_PIPE_TO_CMD"
                    fi
                    ;;
                http)
                    if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                        run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URL' | $FETCH_PIPE_TO_CMD"
                    fi
                    ;;
                lynx)
                    if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                        run "lynx -source '$FETCH_URL' > '$FETCH_OUTPUT_PATH'"
                    else
                        run "lynx -source '$FETCH_URL' | $FETCH_PIPE_TO_CMD"
                    fi
                    ;;
                aria2c)
                    if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                        run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URL'"
                    else
                        run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URL' | $FETCH_PIPE_TO_CMD"
                    fi
                    ;;
                axel)
                    if [ -z "$FETCH_PIPE_TO_CMD" ] ; then
                        run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URL' | $FETCH_PIPE_TO_CMD"
                    fi
                    ;;
                *)  die "fetch() unimplementation: $FETCH_TOOL"
                    ;;
            esac

            [ $? -eq 0 ] || return 1

            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -n "$FETCH_SHA256" ] ; then
                die_if_sha256sum_mismatch "$FETCH_OUTPUT_PATH" "$FETCH_SHA256"
            fi
    esac
}

install_ca_certificates_on_netbsd() {
    # https://www.cambus.net/installing-ca-certificates-on-netbsd/
    if [ "$(uname)" = NetBSD ] ; then
        command -v mozilla-rootcerts > /dev/null || {
            if command -v pkgin > /dev/null ; then
                run $([ "$(whoami)" = root ] || printf 'sudo\n') pkgin -y install mozilla-rootcerts || return 1
            fi
        }
        run mozilla-rootcerts install || true
    fi
}

# }}}
##############################################################################
# {{{ get_china_mirror_url

contains_china_argument() {
    for arg in $@
    do
        case $arg in
            --china) return 0
        esac
    done
    return 1
}

# get_china_mirror_url <ORIGIN_URL> [--china]
get_china_mirror_url() {
    if [ -z "$1" ] ; then
        die "get_china_mirror_url() please specify a url."
    fi

    if contains_china_argument $@ ; then
        case $1 in
            *githubusercontent.com*)
                printf "%s" "$1" | sed 's@githubusercontent.com@githubusercontents.com@'
                ;;
            *github.com*)
                printf "%s" "$1" | sed 's@github.com@github.com.cnpm.org@'
                ;;
        esac
    else
        printf "%s" "$1"
    fi
}

# }}}
##############################################################################
# {{{ __upgrade_self

# __upgrade_self <UPGRAGE_URL> [-x | --china]
__upgrade_self() {
    set -e

    if [ -z "$1" ] ; then
        die "__upgrade_self() please specify a url."
    fi

    for arg in $@
    do
        case $arg in
            -x) set -x ; break
        esac
    done

    unset CURRENT_SCRIPT_REALPATH

    # if file exists and is a symbolic link
    if [ -L "$CURRENT_SCRIPT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            CURRENT_SCRIPT_REALPATH=$(realpath $CURRENT_SCRIPT_FILEPATH)
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            CURRENT_SCRIPT_REALPATH=$(readlink -f $CURRENT_SCRIPT_FILEPATH)
        else
            handle_dependency required exe realpath
            CURRENT_SCRIPT_REALPATH=$(realpath $CURRENT_SCRIPT_FILEPATH)
        fi
    else
        CURRENT_SCRIPT_REALPATH="$CURRENT_SCRIPT_FILEPATH"
    fi

    info "mktemp -d"
    WORKING_DIR=$(mktemp -d)

    run cd $WORKING_DIR

    fetch "$(get_china_mirror_url $@)" --output-path="$WORKING_DIR/self"

    __upgrade_self_exit() {
        if [ -w "$CURRENT_SCRIPT_REALPATH" ] ; then
            run      install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        else
            run sudo install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        fi

        run rm -rf $WORKING_DIR
    }

    trap __upgrade_self_exit EXIT
}

# }}}
##############################################################################
# {{{ __integrate_zsh_completions

# __integrate_zsh_completions <ZSH_COMPLETIONS_SCRIPT_URL> [-x | --china]
__integrate_zsh_completions() {
    set -e

    if [ -z "$1" ] ; then
        die "__integrate_zsh_completions() please specify a url."
    fi

    for arg in $@
    do
        case $arg in
            -x) set -x ; break
        esac
    done

    ZSH_COMPLETIONS_SCRIPT_FILENAME="_$CURRENT_SCRIPT_FILENAME"

    if [ "$(uname)" = Linux ] && command -v termux-info > /dev/null && [ "$HOME" = '/data/data/com.termux/files/home' ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/data/data/com.termux/files/usr/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/usr/local/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    fi

    # if file exists and is a symbolic link
    if [ -L "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(readlink -f $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        else
            handle_dependency required exe realpath
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        fi
    fi

    info "mktemp -d"
    WORKING_DIR=$(mktemp -d)

    run cd $WORKING_DIR

    fetch "$(get_china_mirror_url $@)" --output-path="$WORKING_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"

    if [ -f "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_DIR="$(dirname "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")"
        if [ ! -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" || run sudo install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR"
        fi
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    fi

    run rm -rf $WORKING_DIR

    echo "\n${COLOR_YELLOW}Note: you need to run command${COLOR_RED} ${COLOR_GREEN}autoload -U compinit && compinit${COLOR_OFF} ${COLOR_YELLOW}in zsh to make it work.${COLOR_OFF}"
}

# }}}
##############################################################################
# {{{ os

__get_os_kind_from_uname() {
    case $1 in
        msys*)    printf '%s\n' 'windows' ;;
        mingw32*) printf '%s\n' 'windows' ;;
        mingw64*) printf '%s\n' 'windows' ;;
        cygwin*)  printf '%s\n' 'windows' ;;
        *)        printf '%s\n' "$1"
    esac
}

__get_os_type_from_uname_a() {
    if [ $# -eq 0 ] ; then
        if command -v uname > /dev/null ; then
            __get_os_type_from_uname_a "$(uname -a | cut -d ' ' -f2)"
        else
            return 1
        fi
    else
        case $1 in
            opensuse*) return 1 ;;
            *-*) printf '%s\n' "$1" | cut -d- -f1 | tr A-Z a-z ;;
            *)   return 1
        esac
    fi
}

__get_os_version_from_uname_a() {
    if [ $# -eq 0 ] ; then
        if command -v uname > /dev/null ; then
            __get_os_version_from_uname_a "$(uname -a | cut -d ' ' -f2)"
        else
            return 1
        fi
    else
        case $1 in
            opensuse*) return 1 ;;
            *-*) printf '%s\n' "$1" | cut -d- -f2 ;;
            *)   return 1
        esac
    fi
}

# https://www.freedesktop.org/software/systemd/man/os-release.html
__get_os_type_from_etc_os_release() {
    if [ -e /etc/os-release ] ; then
        (
            . /etc/os-release || return 1
            if [ -z "$ID" ] ; then
                return 1
            else
                printf '%s\n' "$ID" | tr A-Z a-z
            fi
        )
    else
        return 1
    fi
}

__get_os_version_from_etc_os_release() {
    if [ -f /etc/os-release ] ; then
        (
            . /etc/os-release || return 1
            if [ -z "$VERSION_ID" ] ; then
                printf '%s\n' 'rolling'
            else
                printf '%s\n' "$VERSION_ID"
            fi
        )
    else
        return 1
    fi
}

# https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-PDA/LSB-PDA/lsbrelease.html
__get_os_type_from_lsb_release() {
    if command -v lsb_release > /dev/null ; then
        lsb_release --id | cut -f2 | tr A-Z a-z
    else
        return 1
    fi
}

__get_os_version_from_lsb_release() {
    if command -v lsb_release > /dev/null ; then
        lsb_release --release | cut -f2
    else
        return 1
    fi
}

__get_os_type_from_etc_redhat_release() {
    if [ $# -eq 0 ] ; then
        if [ -e /etc/redhat-release ] ; then
            __get_os_type_from_etc_redhat_release "$(cat /etc/redhat-release)"
        else
            return 1
        fi
    else
        case $1 in
            'Red Hat Enterprise Linux release'*)
                printf '%s\n' rhel
                ;;
            'Fedora release'*)
                printf '%s\n' fedora
                ;;
            'CentOS release'*)
                printf '%s\n' centos
                ;;
            'CentOS Linux release'*)
                printf '%s\n' centos
                ;;
            *)  printf '%s\n' "$1" | cut -d ' ' -f1 | tr A-Z a-z
        esac
    fi
}

__get_os_version_from_etc_redhat_release() {
    if [ $# -eq 0 ] ; then
        if [ -e /etc/redhat-release ] ; then
            __get_os_version_from_etc_redhat_release $(cat /etc/redhat-release)
        else
            return 1
        fi
    else
        while [ -n "$1" ]
        do
            case $1 in
                [1-9]*) printf '%s\n' "$1"; return 0
            esac
            shift
        done
        return 1
    fi
}

__get_os_version_from_getprop() {
    if command -v getprop > /dev/null ; then
        getprop ro.build.version.release
    else
        return 1
    fi
}

__get_os_arch_from_uname() {
    if command -v uname > /dev/null ; then
        uname -m 2> /dev/null
    else
        return 1
    fi
}

__get_os_arch_from_arch() {
    if command -v arch > /dev/null ; then
        arch
    else
        return 1
    fi
}

__get_os_type_from_os_kind() {
    case $1 in
        darwin)  printf '%s\n' macos ;;
        linux)
            if [ "$(uname -o 2>/dev/null)" = Android ] ; then
                printf '%s\n' android
            else
                __get_os_type_from_etc_redhat_release ||
                __get_os_type_from_etc_os_release ||
                __get_os_type_from_lsb_release ||
                __get_os_type_from_uname_a
            fi
            ;;
        *) printf '%s\n' "$1"
    esac
}

__get_os_name_from_os_type() {
    case $1 in
        debian)  printf '%s\n' 'Debian' ;;
        ubuntu)  printf '%s\n' 'Ubuntu' ;;
        linuxmint) printf '%s\n' 'LinuxMint' ;;
        centos)  printf '%s\n' 'CentOS' ;;
        fedora)  printf '%s\n' 'Fedora' ;;
        rhel)    printf '%s\n' 'RHEL' ;;
        opensuse-leap)
                 printf '%s\n' 'openSUSE-Leap' ;;
        gentoo)  printf '%s\n' 'Gentoo' ;;
        manjaro) printf '%s\n' 'Manjaro' ;;
        alpine)  printf '%s\n' 'AlpineLinux' ;;
        arch)    printf '%s\n' 'ArchLinux' ;;
        void)    printf '%s\n' 'VoidLinux' ;;
        freebsd) printf '%s\n' 'FreeBSD' ;;
        netbsd)  printf '%s\n' 'NetBSD' ;;
        openbsd) printf '%s\n' 'OpenBSD' ;;
        macos)   printf '%s\n' 'macOS' ;;
        android) printf '%s\n' 'Android' ;;
        windows)
            systeminfo | grep 'OS Name:' | cut -d: -f2 | head -n 1 | sed 's/^[[:space:]]*//'
            ;;
        *) printf '%s\n' "$1"
    esac
}

__get_os_version_from_os_kind() {
    case $1 in
        freebsd) freebsd-version ;;
        openbsd) uname -r ;;
        netbsd)  uname -r ;;
        darwin)  sw_vers -productVersion ;;
        linux)
            __get_os_version_from_etc_redhat_release ||
            __get_os_version_from_etc_os_release ||
            __get_os_version_from_lsb_release ||
            __get_os_version_from_getprop ||
            __get_os_version_from_uname_a
            ;;
        windows)
            systeminfo | grep 'OS Version:' | cut -d: -f2 | head -n 1 | sed 's/^[[:space:]]*//' | cut -d ' ' -f1
            ;;
    esac
}

__get_os_sub_system() {
    case $(uname | tr A-Z a-z) in
        msys*)    printf '%s\n' "msys"    ;;
        mingw32*) printf '%s\n' "mingw32" ;;
        mingw64*) printf '%s\n' "mingw64" ;;
        cygwin*)  printf '%s\n' 'cygwin'  ;;
        *)
            if [ "$(uname -o 2>/dev/null)" = Android ] ; then
                if [ -n "$TERMUX_VERSION" ] ; then
                    printf '%s\n' termux
                fi
            fi
    esac
}

__get_os_arch() {
    __get_os_arch_from_uname ||
    __get_os_arch_from_arch
}

__get_os_libc_from_os_kind() {
    case $1 in
        linux)
            if [ "$(uname -o 2>/dev/null)" = Android ] ; then
                printf '%s\n' bionic
                return 0
            fi
            # https://pubs.opengroup.org/onlinepubs/7908799/xcu/getconf.html
            if command -v getconf > /dev/null ; then
                if getconf GNU_LIBC_VERSION > /dev/null 2>&1 ; then
                    printf '%s\n' glibc
                    return 0
                fi
            fi
            if command -v ldd > /dev/null ; then
                if ldd --version 2>&1 | head -n 1 | grep -q GLIBC ; then
                    printf '%s\n' glibc
                    return 0
                fi
                if ldd --version 2>&1 | head -n 1 | grep -q musl ; then
                    printf '%s\n' musl
                    return 0
                fi
            fi
            return 1
    esac
}

os() {
    if [ $# -eq 0 ] ; then
        printf "current-machine-os-kind : %s\n" "$(os kind)"
        printf "current-machine-os-type : %s\n" "$(os type)"
        printf "current-machine-os-name : %s\n" "$(os name)"
        printf "current-machine-os-vers : %s\n" "$(os vers)"
        printf "current-machine-os-arch : %s\n" "$(os arch)"
        printf "current-machine-os-libc : %s\n" "$(os libc)"
        printf "current-machine-os-subs : %s\n" "$(os subs)"
    elif [ $# -eq 1 ] ; then
        case $1 in
            -h|--help)
                cat <<'EOF'
os -h | --help
os -V | --version
os kind
os type
os name
os vers
os arch
os libc
os subs
EOF
                ;;
            -V|--version)
                printf "%s\n" '2021.10.01.03'
                ;;
            kind)
                __get_os_kind_from_uname $(uname | tr A-Z a-z)
                ;;
            type)
                __get_os_type_from_os_kind $(os kind)
                ;;
            name)
                __get_os_name_from_os_type $(os type)
                ;;
            vers)
                __get_os_version_from_os_kind $(os kind)
                ;;
            subs)
                __get_os_sub_system
                ;;
            arch)
                __get_os_arch
                ;;
            libc)
                __get_os_libc_from_os_kind $(os kind)
                ;;
            *)  printf '%s\n' "unrecognized argument: $1" >&2; return 1
        esac
    else
        printf '%s\n' "os command only support one argument." >&2; return 1
    fi
}

# }}}
##############################################################################
# {{{ version

version_of_python_module() {
    unset PIP_COMMAND
    PIP_COMMAND=$(command -v pip3 || command -v pip)
    if [ -z "$PIP_COMMAND" ] ; then
        die "can't found pip command."
    else
        "$PIP_COMMAND" show $1 | grep 'Version:' | cut -d ' ' -f2
    fi
}

# retrive the version of a command from it's name or path
version_of_command() {
    case $(basename "$1") in
        cmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         make) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        gmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
       rustup) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        cargo) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           go) "$1"   version | cut -d ' ' -f3 | cut -c3- ;;
         tree) "$1" --version | cut -d ' ' -f2 | cut -c2- ;;
   pkg-config) "$1" --version 2> /dev/null | head -n 1 ;;
       m4|gm4) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}';;
    autopoint) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     automake|aclocal)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     autoconf|autoheader|autom4te|autoreconf|autoscan|autoupdate|ifnames)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      libtool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
   libtoolize|glibtoolize)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      objcopy) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f5 ;;
         flex) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bison) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         yacc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         nasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         yasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        patch) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}' ;;
        gperf) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        groff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     help2man) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
 sphinx-build) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         file) "$1" --version 2> /dev/null | head -n 1 | cut -d '-' -f2 ;;
      itstool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       protoc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        xmlto) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
      xmllint) ;;
     xsltproc) ;;
     rst2man|rst2man.py|rst2man-3|rst2man-3.6|rst2man-3.7|rst2man-3.8|rst2man-3.9)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         gzip) "$1" --version 2>&1 | head -n 1 | awk '{print($NF)}' ;;
         lzip) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           xz) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
          zip) "$1" --version 2> /dev/null | sed -n '2p' | cut -d ' ' -f4 ;;
        unzip) "$1" -v        2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bzip2) "$1" --help 2>&1 | head -n 1 | cut -d ' ' -f8 | cut -d ',' -f1 ;;
          tar)
            VERSION_MSG=$("$1" --version 2> /dev/null | head -n 1)
            case $VERSION_MSG in
                  tar*) echo "$VERSION_MSG" | cut -d ' ' -f4 ;;
               bsdtar*) echo "$VERSION_MSG" | cut -d ' ' -f2 ;;
            esac
            ;;
          git) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         curl) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
     awk|gawk) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 | tr , ' ' ;;
     sed|gsed) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         cpan) ;;
         find) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         diff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         grep) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '-' -f1 ;;
         ruby) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         perl) "$1" -v | sed -n '2p' | sed 's/.*v\([0-9]\.[0-9][0-9]\.[0-9]\).*/\1/' ;;
    python|python2|python3)
               "$1" --version 2>&1 | head -n 1 | cut -d ' ' -f2 ;;
         pip)  "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         pip3) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         node) "$1" --version 2> /dev/null | head -n 1 | cut -d 'v' -f2 ;;
          zsh) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         bash) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '(' -f1 ;;
       base64) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
            *) "$1" --version 2> /dev/null | head -n 1
    esac
}

# retrive the major part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_major_of_command() {
    version_of_command "$1" | cut -d. -f1
}

# retrive the minor part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_minor_of_command() {
    version_of_command "$1" | cut -d. -f2
}

# retrive the major part of the given version
# Note: the given version must have form: major.minor.patch
version_major_of_version() {
    echo "$1" | cut -d. -f1
}

# retrive the minor part of the given version
# Note: the given version must have form: major.minor.patch
version_minor_of_version() {
    echo "$1" | cut -d. -f2
}

version_sort() {
    # https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html
    # https://man.netbsd.org/NetBSD-8.1/i386/sort.1
    #
    # sort: unrecognized option: V
    # BusyBox v1.29.3 (2019-01-24 07:45:07 UTC) multi-call binary.
    # Usage: sort [-nrugMcszbdfiokt] [-o FILE] [-k start[.offset][opts][,end[.offset][opts]] [-t CHAR] [FILE]...
    if  echo | (sort -V > /dev/null 2>&1) ; then
        echo "$@" | tr ' ' '\n' | sort -V
    else
        echo "$@" | tr ' ' '\n' | sort -t. -n -k1,1 -k2,2 -k3,3 -k4,4
    fi
}

# check if match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# version_match 1.15.3 eq 1.16.0
# version_match 1.15.3 lt 1.16.0
# version_match 1.15.3 gt 1.16.0
# version_match 1.15.3 le 1.16.0
# version_match 1.15.3 ge 1.16.0
version_match() {
    case $2 in
        eq)  [ "$1"  = "$3" ] ;;
        ne)  [ "$1" != "$3" ] ;;
        le)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        ge)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        lt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        gt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        *)  die "version_compare: $2: not supported operator."
    esac
}

# check if the version of give installed command match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# command_exists_in_filesystem_and_version_matched automake eq 1.16.0
# command_exists_in_filesystem_and_version_matched automake lt 1.16.0
# command_exists_in_filesystem_and_version_matched automake gt 1.16.0
# command_exists_in_filesystem_and_version_matched automake le 1.16.0
# command_exists_in_filesystem_and_version_matched automake ge 1.16.0
# command_exists_in_filesystem_and_version_matched automake
command_exists_in_filesystem_and_version_matched() {
    if command_exists_in_filesystem "$1" ; then
        if [ $# -eq 3 ] ; then
            version_match "$(version_of_command "$1")" "$2" "$3"
        fi
    else
        return 1
    fi
}

# }}}
##############################################################################
# {{{ package_manager

# check if the version of give package match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# is_package_available_and_version_matched_in_package_manager apt automake eq 1.16.0
# is_package_available_and_version_matched_in_package_manager apt automake lt 1.16.0
# is_package_available_and_version_matched_in_package_manager apt automake gt 1.16.0
# is_package_available_and_version_matched_in_package_manager apt automake le 1.16.0
# is_package_available_and_version_matched_in_package_manager apt automake ge 1.16.0
# is_package_available_and_version_matched_in_package_manager apt automake
is_package_available_and_version_matched_in_package_manager() {
    if is_package_available_in_package_manager "$1" "$2" ; then
        if [ $# -eq 4 ] ; then
            case $1 in
                apt|apk|yum|dnf) version_match "$(get_package_version_by_package_name_in_package_manager "$1" "$2")" "$3" "$4" ;;
                *)       return 0 ;;
            esac
        fi
    else
        return 1
    fi
}

# check if the given package is in the given package manager's repo
#
# examples:
# is_package_available_in_package_manager apt automake
is_package_available_in_package_manager() {
    case $1 in
        #pkg) pkg show "$2" > /dev/null 2>&1 ;;
        apt) apt show "$2" > /dev/null 2>&1 ;;
        apk) apk info "$2" > /dev/null 2>&1 ;;
        yum) yum info "$2" > /dev/null 2>&1 ;;
        dnf) dnf info "$2" > /dev/null 2>&1 ;;
    esac
}

# get the version of the given package in the given package manager's repo
#
# examples:
# get_package_version_by_package_name_in_package_manager apt automake
get_package_version_by_package_name_in_package_manager() {
    case $1 in
        pkg) pkg show "$2" 2> /dev/null | grep 'Version: '      | head -n 1 | cut -d ' ' -f2 | cut -d- -f1 ;;
        apt) apt show "$2" 2> /dev/null | grep 'Version: '      | head -n 1 | cut -d ' ' -f2 | cut -d- -f1 ;;
        apk) apk info "$2" 2> /dev/null | head -n 1 | cut -d ' ' -f1 | cut -d- -f2 ;;
        yum) yum info "$2" 2> /dev/null | grep 'Version     :'  | head -n 1 | cut -d : -f2 | sed 's/^[[:space:]]//' ;;
        dnf) dnf info "$2" 2> /dev/null | grep 'Version      :' | head -n 1 | cut -d : -f2 | sed 's/^[[:space:]]//' ;;
    esac
}

# }}}
##############################################################################
# {{{ get_package_name_by_command_name_in_package_manager_XX

# https://cygwin.com/packages/package_list.html
get_package_name_by_command_name_in_package_manager_choco() {
    case $1 in
          go) echo 'golang' ;;
      cc|gcc|c++|g++)
              echo 'gcc-g++';;
       gmake) echo 'make'   ;;
         gm4) echo 'm4'     ;;
        gsed) echo 'gnu-sed';;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    sphinx-build) echo 'python38-sphinx' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_pkg_add() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
    realpath) echo 'coreutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip3|pip) echo 'py3-pip' ;;
    libtool|libtoolize|glibtool|glibtoolize)
              echo "libtool" ;;
    autoreconf|autoconf|autoreconf-2.69|autoconf-2.69)
              echo "autoconf-2.69p3" ;;
    automake|autoheader|automake-1.16|autoheader-1.16)
            if [ "$NATIVE_OS_VERS" = '6.9' ] ; then
                echo "automake-1.16.3"
            else
                echo "automake-1.16.2"
            fi
            ;;
    autopoint) echo "gettext" ;;
    pkg-config) echo "pkgconf" ;;
        *) echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_pkgin() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip3|pip) echo 'py38-pip'  ;;
    python3)  echo 'python38' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_pkg() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip3|pip) echo 'py38-pip' ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_emerge() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      xz)     echo 'xz-utils' ;;
      tree)   echo 'app-text/tree' ;;
      rst2man|rst2html)
              echo "docutils" ;;
    sphinx-build)
              echo "sphinx" ;;
    pip3|pip) echo "dev-python/pip" ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

__get_package_name_by_command_name_in_package_manager_pacman() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      rst2man|rst2html)
              echo "python-docutils" ;;
    sphinx-build)
              echo "python-sphinx" ;;
    pip3|pip) echo "python-pip" ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

__mingw_w64_i686() {
    if pacman -S -i "mingw-w64-i686-$1" > /dev/null 2>&1 ; then
        echo "mingw-w64-i686-$1"
    else
        echo "$1"
    fi
}

__mingw_w64_x86_64() {
    if pacman -S -i "mingw-w64-x86_64-$1" > /dev/null 2>&1 ; then
        echo "mingw-w64-x86_64-$1"
    else
        echo "$1"
    fi
}

get_package_name_by_command_name_in_package_manager_pacman() {
    if [ "$1" = 'make' ] || [ "$1" = 'gmake' ] ; then
        echo make
    fi
    case $NATIVE_OS_SUBS in
        mingw32) __mingw_w64_i686   $(__get_package_name_by_command_name_in_package_manager_pacman "$1") ;;
        mingw64) __mingw_w64_x86_64 $(__get_package_name_by_command_name_in_package_manager_pacman "$1") ;;
        *) __get_package_name_by_command_name_in_package_manager_pacman "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_xbps() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip|pip3) echo "python3-pip" ;;
    rst2man|rst2html)
              echo "python3-docutils" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_apk() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip3|pip) echo 'py3-pip' ;;
    rst2man|rst2html)
              echo "py3-docutils" ;;
    sphinx-build)
              echo "sphinx"  ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    pkg-config) echo "pkgconf"  ;;
        *) echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_zypper() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'gcc-g++';;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      rst2man|rst2html)
              echo "python3-docutils" ;;
    sphinx-build)
              echo "python3-Sphinx" ;;
    pip3|pip) echo "python3-pip" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    autopoint)  echo "gettext"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_dnf() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
      rst2man|rst2html)
              echo "python3-docutils" ;;
    sphinx-build)
              echo "python3-sphinx" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_yum() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'gcc-g++';;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    sphinx-build) echo "python-sphinx" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_apt_get() {
    get_package_name_by_command_name_in_package_manager_apt $@
}

get_package_name_by_command_name_in_package_manager_apt() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
        xz)   echo 'xz-utils' ;;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
    pip3|pip) echo "python3-pip" ;;
    rst2man|rst2html)
              echo "python3-docutils" ;;
    sphinx-build)
              echo "python3-sphinx" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
        ninja)
            if [ "$NATIVE_OS_SUBS" = termux ] ; then
                echo ninja
            else
                echo ninja-build
            fi
            ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_brew() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip' ;;
      protoc) echo 'protobuf' ;;
      ps2pdf) echo "ghostscript" ;;
     rst2man.py|rst2html.py)
              echo "docutils" ;;
    grpc_cpp_plugin)
                echo "grpc" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
    python|python3)
                echo 'python@3.9' ;;
        *)      echo "$1"
    esac
}

get_package_name_by_command_name_in_package_manager_pip3() {
    get_package_name_by_command_name_in_package_manager_pip $@
}

get_package_name_by_command_name_in_package_manager_pip() {
    case $1 in
        sphinx-build) echo "sphinx"   ;;
        rst2man.py)   echo "docutils" ;;
    esac
}

# }}}
##############################################################################
# {{{ __get_available_package_manager_list

__add_available_package_manager() {
    if command_exists_in_filesystem "$1" ; then
        if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
            AVAILABLE_PACKAGE_MANAGER_LIST="$2"
        else
            AVAILABLE_PACKAGE_MANAGER_LIST="$AVAILABLE_PACKAGE_MANAGER_LIST $2"
        fi
    fi
}

__get_available_package_manager_list() {
    if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
        for pm in brew apt dnf zypper apk xbps-install emerge pacman choco pkg pkgin pkg_add
        do
            case $pm in
                apt)
                    if command_exists_in_filesystem apt && apt show apt > /dev/null 2>&1 ; then
                        __add_available_package_manager apt apt
                    else
                        __add_available_package_manager apt-get apt-get
                    fi
                    ;;
                dnf)
                    if command_exists_in_filesystem dnf ; then
                        __add_available_package_manager dnf dnf
                    else
                        __add_available_package_manager yum yum
                    fi
                    ;;
                xbps-install)
                    __add_available_package_manager xbps-install xbps
                    ;;
                *)  __add_available_package_manager "$pm" "$pm"
            esac
        done
    fi
    echo "$AVAILABLE_PACKAGE_MANAGER_LIST"
}

# }}}
##############################################################################
# {{{ __install_required

# $1 package manager name
# $2 package name
# examples:
# __install_package_via_package_manager apt make ge 3.80
# __install_package_via_package_manager apt make
__install_package_via_package_manager() {
    if [ -z "$2" ] ; then
        return 1
    fi

    is_package_available_and_version_matched_in_package_manager $@ || return 1

    case $1 in
        pip3)
            case $NATIVE_OS_KIND in
                *bsd|linux) run pip3 install --user -U "$2" ;;
                *)          run pip3 install        -U "$2"
            esac
            ;;
        pip)
            case $NATIVE_OS_KIND in
                *bsd|linux) run pip  install --user -U "$2" ;;
                *)          run pip  install        -U "$2"
            esac
            ;;
        brew)
            if run brew install "$2" ; then
                if [ "$(brew info --json=v2 "$2" | grep keg_only | sed 's/ //g' | cut -d: -f2 | sed 's/,//')" = 'true' ] ; then
                    if [ -d "$(brew --prefix "$2")/bin" ] ; then
                        export PATH="$(brew --prefix "$2")/bin:$PATH"
                    fi
                fi
            else
                return 1
            fi
            ;;
        pkg)     run $sudo pkg install -y "$2" ;;
        pkgin)   run $sudo pkgin -y install "$2" ;;
        pkg_add) run $sudo pkg_add "$2" ;;
        apt)     run $sudo apt     -y install "$2" ;;
        apt-get) run $sudo apt-get -y install "$2" ;;
        dnf)     run $sudo dnf -y install "$2" ;;
        yum)     run $sudo yum -y install "$2" ;;
        zypper)  run $sudo zypper install -y "$2" ;;
        apk)     run $sudo apk add "$2" ;;
        xbps)    run $sudo xbps-install -Sy "$2" ;;
        emerge)  run $sudo emerge "$2" ;;
        pacman)  run $sudo pacman -Syy --noconfirm && run $sudo pacman -S --noconfirm "$2" ;;
        choco)   run choco install -y --source cygwin "$2" ;;
    esac
    echo
}

# $1 package manager name
# $2 command name
# examples:
# __install_command_via_package_manager apt make ge 3.80
# __install_command_via_package_manager apt make
__install_command_via_package_manager() {
    unset __PACKAGE_NAME__
    __PACKAGE_NAME__="$(eval get_package_name_by_command_name_in_package_manager_$(echo "$1" | tr - _) $2)"

    if [ -z "$__PACKAGE_NAME__" ] ; then
        return 1
    fi

    is_package_available_and_version_matched_in_package_manager "$1" "$__PACKAGE_NAME__" $3 $4 || return 1

    print "ðŸ”¥  ${COLOR_GREEN}$(shiftn 1 $@)${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found, I will install it via${COLOR_OFF} ${COLOR_GREEN}$1${COLOR_OFF}\n"

    __install_package_via_package_manager "$1" "$__PACKAGE_NAME__" $3 $4
}

# examples:
# __install_command_via_available_package_manager python3 ge 3.5
# __install_command_via_available_package_manager make
__install_command_via_available_package_manager() {
    if command_exists_in_filesystem_and_version_matched $@ ; then
        return 0
    fi
 
    if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
        AVAILABLE_PACKAGE_MANAGER_LIST=$(__get_available_package_manager_list)
        if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
            warn "no package manager found."
            return 1
        else
            echo "    Found $(list_length $AVAILABLE_PACKAGE_MANAGER_LIST) package manager : ${COLOR_GREEN}$AVAILABLE_PACKAGE_MANAGER_LIST${COLOR_OFF}"
        fi
    fi
    for pm in $AVAILABLE_PACKAGE_MANAGER_LIST
    do
        if __install_command_via_package_manager "$pm" $@ ; then
            return 0
        fi
    done
    return 1
}

handle_dependency_from_url() {
    case $1 in
        *.zip)
            handle_dependency required exe unzip
            ;;
        *.tar.xz)
            handle_dependency required exe tar
            handle_dependency required exe xz
            ;;
        *.tar.gz)
            handle_dependency required exe tar
            handle_dependency required exe gzip
            ;;
        *.tar.lz)
            handle_dependency required exe tar
            handle_dependency required exe lzip
            ;;
        *.tar.bz2)
            handle_dependency required exe tar
            handle_dependency required exe bzip2
            ;;
        *.tgz)
            handle_dependency required exe tar
            handle_dependency required exe gzip
            ;;
        *.txz)
            handle_dependency required exe tar
            handle_dependency required exe xz
    esac
}

get_suffix_from_filename() {
    case $1 in
        *.zip)     echo '.zip' ;;
        *.tar.xz)  echo '.tar.xz' ;;
        *.tar.gz)  echo '.tar.gz' ;;
        *.tar.lz)  echo '.tar.lz' ;;
        *.tar.bz2) echo '.tar.bz2' ;;
        *.tgz)     echo '.tgz' ;;
        *.txz)     echo '.txz' ;;
    esac
}

# examples:
# pkg-config ge 0.18
# python3    ge 3.5
# make
__install_command_via_fetch_prebuild_binary() {
    unset PREBUILD_BINARY_FETCH_URL
    PREBUILD_BINARY_FETCH_URL=$(__get_prebuild_binary_fetch_url_by_command_name "$1")
    if [ -z "$PREBUILD_BINARY_FETCH_URL" ] ; then
        return 1
    fi

    handle_dependency_from_url "$PREBUILD_BINARY_FETCH_URL"

    print "ðŸ”¥  ${COLOR_GREEN}$@${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found, I will install it via${COLOR_OFF} ${COLOR_GREEN}fetch prebuild binary${COLOR_OFF}\n"

    unset PREBUILD_BINARY_FETCH_URL
    PREBUILD_BINARY_FETCH_URL=$(__get_prebuild_binary_fetch_url_by_command_name "$1")

    unset PREBUILD_BINARY_FILENAME_PREFIX
    unset PREBUILD_BINARY_FILENAME_SUFFIX
    unset PREBUILD_BINARY_FILENAME
    unset PREBUILD_BINARY_FILEPATH

    PREBUILD_BINARY_FILENAME=$(basename "$PREBUILD_BINARY_FETCH_URL")
    PREBUILD_BINARY_FILENAME_SUFFIX=$(get_suffix_from_filename "$PREBUILD_BINARY_FILENAME")
    PREBUILD_BINARY_FILENAME_PREFIX=$(basename "$PREBUILD_BINARY_FILENAME" "$PREBUILD_BINARY_FILENAME_SUFFIX")

    if [ -z "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] ; then
        PREBUILD_BINARY_INSTALL_PREFIX_DIR='/opt'
    fi

    unset PREBUILD_BINARY_INSTALL_DIR
    PREBUILD_BINARY_INSTALL_DIR="$PREBUILD_BINARY_INSTALL_PREFIX_DIR/$PREBUILD_BINARY_FILENAME_PREFIX"

    PREBUILD_BINARY_FILEPATH="$PREBUILD_BINARY_INSTALL_DIR/$PREBUILD_BINARY_FILENAME"

    if [ -d "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] ; then
        if [ -d "$PREBUILD_BINARY_INSTALL_DIR" ] ; then
            if [ -r "$PREBUILD_BINARY_INSTALL_DIR" ] && [ -w "$PREBUILD_BINARY_INSTALL_DIR" ] && [ -x "$PREBUILD_BINARY_INSTALL_DIR" ] ; then
                rm -rf "$PREBUILD_BINARY_INSTALL_DIR" || return 1
                install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
            else
                sudo rm -rf "$PREBUILD_BINARY_INSTALL_DIR" || return 1
                sudo install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
            fi
        else
            if [ -r "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] && [ -w "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] && [ -x "$PREBUILD_BINARY_INSTALL_PREFIX_DIR" ] ; then
                     install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
            else
                sudo install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
            fi
        fi
    else
        if [ -r / ] && [ -w / ] && [ -x / ] ; then
                 install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
        else
            sudo install -o $(whoami) -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1
        fi
    fi

    fetch "$PREBUILD_BINARY_FETCH_URL" --output-dir="$PREBUILD_BINARY_INSTALL_DIR" --output-name="$PREBUILD_BINARY_FILENAME" || return 1

    case $PREBUILD_BINARY_FILENAME_SUFFIX in
        .zip)
            run unzip  "$PREBUILD_BINARY_FILEPATH" -d "$PREBUILD_BINARY_INSTALL_DIR" || return 1 ;;
        .tar.xz|.tar.gz|.tar.lz|.tar.bz2|.tgz|.txz|.tlz)
            run tar xf "$PREBUILD_BINARY_FILEPATH" -C "$PREBUILD_BINARY_INSTALL_DIR" --strip-components 1 || return 1 ;;
    esac

    if [ -d "$PREBUILD_BINARY_INSTALL_DIR/bin" ] ; then
        export PATH="$PREBUILD_BINARY_INSTALL_DIR/bin:$PATH"
    fi

    case $1 in
        autoconf)
            for xx in $(grep '/root/.zpkg/install.d/autoconf' -rl "$PREBUILD_BINARY_INSTALL_DIR")
            do
                sed_in_place "s|/root/.zpkg/install.d/autoconf|$PREBUILD_BINARY_INSTALL_DIR|" "$xx"
            done
            ;;
    esac
}

# examples:
# __get_prebuild_binary_fetch_url_by_command_name python3 ge 3.5
# __get_prebuild_binary_fetch_url_by_command_name cmake
__get_prebuild_binary_fetch_url_by_command_name() {
    # https://github.com/leleliu008/python-prebuild
    # https://cmake.org/download
{
    cat <<EOF
python    |glibc|linux |x86_64|https://github.com/leleliu008/python-prebuild/releases/download/3.9.5/python-3.9.5-x86_64-linux-glibc.tar.xz
python3   |glibc|linux |x86_64|https://github.com/leleliu008/python-prebuild/releases/download/3.9.5/python-3.9.5-x86_64-linux-glibc.tar.xz
git       |glibc|linux |x86_64|https://github.com/leleliu008/git-prebuild/releases/download/2.30.2/git-2.30.2-x86_64-linux-glibc.tar.xz
autoconf  |glibc|linux |x86_64|https://github.com/leleliu008/autoconf-prebuild/releases/download/2.69/autoconf-2.69-glibc-linux-x86_64.tar.gz
autoreconf|glibc|linux |x86_64|https://github.com/leleliu008/autoconf-prebuild/releases/download/2.69/autoconf-2.69-glibc-linux-x86_64.tar.gz
cmake     |glibc|linux |x86_64|https://github.com/Kitware/CMake/releases/download/v3.20.2/cmake-3.20.2-linux-x86_64.tar.gz
cmake     |     |darwin|      |https://github.com/Kitware/CMake/releases/download/v3.20.2/cmake-3.20.2-macos-universal.tar.gz
EOF
} | while read LINE
    do
        LINE=$(printf '%s' "$LINE" | sed 's/[[:space:]]//g')

        unset __PB_COMMAND__
        unset __PB_OS_LIBC__
        unset __PB_OS_KIND__
        unset __PB_OS_ARCH__
        unset __PB_URL__

        __PB_COMMAND__=$(printf '%s' "$LINE" | cut -d '|' -f1)

        if [ "$__PB_COMMAND__" != "$1" ] ; then
            continue
        fi

        __PB_OS_LIBC__=$(printf '%s' "$LINE" | cut -d '|' -f2)

        if [ -n "$__PB_OS_LIBC__" ] && [ "$__PB_OS_LIBC__" != "$NATIVE_OS_LIBC" ] ; then
            continue
        fi

        __PB_OS_KIND__=$(printf '%s' "$LINE" | cut -d '|' -f3)

        if [ "$__PB_OS_KIND__" != "$NATIVE_OS_KIND" ] ; then
            continue
        fi

        __PB_OS_ARCH__=$(printf '%s' "$LINE" | cut -d '|' -f4)

        if [ -n "$__PB_OS_ARCH__" ] && [ "$__PB_OS_ARCH__" != "$NATIVE_OS_ARCH" ] ; then
            continue
        fi

        __PB_URL__=$(printf '%s' "$LINE" | cut -d '|' -f5)

        echo "$__PB_URL__"
    done
}

__install_command_via_run_install_script() {
    case $1 in
        rustup)
            # https://www.rust-lang.org/tools/install
            print "ðŸ”¥  ${COLOR_GREEN}$1${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found, I will install it via running shell script.${COLOR_OFF}\n"

            handle_dependency required exe bash:zsh

            fetch 'https://sh.rustup.rs' --pipe="$(command -v bash || command -v zsh || command -v dash || command -v ash || echo sh)"

            export CARGO_HOME=$HOME/.cargo
            export PATH="$CARGO_HOME/bin:$PATH"
            ;;
        nvm)
            # https://github.com/nvm-sh/nvm
            print "ðŸ”¥  ${COLOR_GREEN}$1${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found, I will install it via running bash shell script.${COLOR_OFF}\n"

            handle_dependency required exe bash:zsh

	        fetch "$(github_user_content_base_url)/nvm-sh/nvm/master/install.sh" --pipe="$(command -v bash || command -v zsh || echo bash)"

	        export NVM_DIR="${HOME}/.nvm"
	        . "${HOME}/.nvm/nvm.sh"
            ;;
        *)  return 1
    esac
}

__install_command_via_pip() {
    if [ -z "$(get_package_name_by_command_name_in_package_manager_pip3 "$1")" ] ; then
        return 1
    fi

    handle_dependency required exe pip3:pip

    (
        unset __PIP_COMMAND__
        __PIP_COMMAND__="$(command -v pip3.8)"

        if [ -n "$__PIP_COMMAND__" ] && [ -d '/usr/local/bin' ] ; then
            $sudo ln -sf "$__PIP_COMMAND__" /usr/local/bin/pip3
        fi
    )

    if   command_exists_in_filesystem pip3 ; then
        __install_package_via_package_manager pip3 "$(get_package_name_by_command_name_in_package_manager_pip3 "$1")"
    elif command_exists_in_filesystem pip ; then
        __install_package_via_package_manager pip  "$(get_package_name_by_command_name_in_package_manager_pip "$1")"
    else
        return 1
    fi
}

# examples:
# __install_command python3 ge 3.5
# __install_command make
__install_command() {
    if command_exists_in_filesystem_and_version_matched $@ ; then
        return 0
    fi

    if __install_command_via_run_install_script $@ ; then
        return 0
    fi

    if __install_command_via_pip $@ ; then
        return 0
    fi

    if __install_command_via_available_package_manager $@ ; then
        return 0
    fi

    if __install_command_via_fetch_prebuild_binary $@ ; then
        return 0
    fi

    print "ðŸ”¥  ${COLOR_GREEN}$@${COLOR_OFF} ${COLOR_YELLOW}command is required, but I found no way to install it.${COLOR_OFF}\n"
    return 1
}

# examples:
# handle_dependency required exe   pkg-config ge 0.18
# handle_dependency required exe   python     ge 3.5
# handle_dependency required py    libxml2    ge 2.19
#
# handle_dependency optional exe   pkg-config ge 0.18
# handle_dependency optional exe   python     ge 3.5
# handle_dependency optional py    libxml2    ge 2.19
handle_dependency() {
    [ "$1" = 'required' ] || return 0

    shift

    case $1 in
        exe)
            shift
            case $1 in
                *:*)
                    for command in $(echo "$1" | tr ':' ' ')
                    do
                        if command_exists_in_filesystem_and_version_matched "$command" $2 $3 ; then
                            map_set MAP_REQUIRED_DEPENDENCIES "$1" "$command"
                            return 0
                        fi
                    done
                    for command in $(echo "$1" | tr ':' ' ')
                    do
                        if __install_command "$command" $2 $3 ; then
                            map_set MAP_REQUIRED_DEPENDENCIES "$1" "$command"
                            return 0
                        fi
                    done
                    return 1
                    ;;
                *)  __install_command $@
            esac
            ;;
        py)
            shift
            python_module install "$1"
            ;;
        pm)
            shift
            perl_module install "$1"
            ;;
        *) die "handle_dependency() unrecognized argument:$1"
    esac
}

__handle_required_dependencies() {
    step "handle required dependencies"

    for dependency in $REQUIRED_DEPENDENCY_LIST
    do
        handle_dependency $(__decode_dependency "$dependency") || return 1
    done
}

# }}}
##############################################################################
# {{{ __printf_dependencies

# examples:
# __printf_dependency required exe   pkg-config ge 0.18
# __printf_dependency required exe   python     ge 3.5
# __printf_dependency required py    libxml2    ge 2.19
#
# __printf_dependency optional exe   pkg-config ge 0.18
# __printf_dependency optional exe   python     ge 3.5
# __printf_dependency optional py    libxml2    ge 2.19
__printf_dependency() {
    printf "%-10s %-15s %-2s %-10s %-10s %s\n" "$1" "$2" "$3" "$4" "$5" "$6"
}

# examples:
# printf_dependency required exe   pkg-config ge 0.18
# printf_dependency required exe   python     ge 3.5
# printf_dependency required py    libxml2    ge 2.19
#
# printf_dependency optional exe   pkg-config ge 0.18
# printf_dependency optional exe   python     ge 3.5
# printf_dependency optional py    libxml2    ge 2.19
printf_dependency() {
    case $2 in
        exe)
            case $3 in
                *:*)
                    if [ "$1" = 'required' ] ; then
                        REQUIRED_ITEM="$(map_get MAP_REQUIRED_DEPENDENCIES "$3")"
                        __printf_dependency "$2" "$REQUIRED_ITEM" "$4" "$5" "$(version_of_command $REQUIRED_ITEM)" "$(command -v $REQUIRED_ITEM)"
                    else
                        for item in $(echo "$3" | tr ':' ' ')
                        do
                            __printf_dependency "$2" "$item" "$4" "$5" "$(version_of_command $item)" "$(command -v $item)"
                        done
                    fi
                    ;;
                *)  __printf_dependency "$2" "$3" "$4" "$5" "$(version_of_command $3)" "$(command -v $3)"
            esac
            ;;
        py)
            __printf_dependency "$2" "$3" "$4" "$5" "$(python_module get version "$item")" "$(python_module get location "$item")"
            ;;
        pm)
            __printf_dependency "$2" "$3" "$4" "$5" "$(perl_module get version "$item")" "$(perl_module get location "$item")"
            ;;
        *)  die "printf_dependency() unrecognized argument: $2"
    esac
}

__printf_required_dependencies() {
    step "printf required dependencies"
    if [ -z "$REQUIRED_DEPENDENCY_LIST" ] ; then
        warn "no required dependencies."
    else
        __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
        for dependency in $REQUIRED_DEPENDENCY_LIST
        do
            printf_dependency $(__decode_dependency "$dependency")
        done
    fi
}

__printf_optional_dependencies() {
    step "printf optional dependencies"
    if [ -z "$OPTIONAL_DEPENDENCY_LIST" ] ; then
        warn "no optional dependencies."
    else
        __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
        for dependency in $OPTIONAL_DEPENDENCY_LIST
        do
            printf_dependency $(__decode_dependency "$dependency")
        done
    fi
}

# }}}
##############################################################################
# {{{ python_module

# examples:
# python_module is  installed libxml2
# python_module get version   libxml2
# python_module get location  libxml2
# python_module install       libxml2
python_module() {
    case $1 in
        is)
            [ $# -eq 3 ] || die "[python_module is] command accept 2 arguments."

            handle_dependency required exe python3:python3.9:python3.8:python3.7:python3.6:python3.5:python
            handle_dependency required exe pip3:pip3.9:pip3.8:pip3.7:pip3.6:pip3.5:pip

            __PYTHON_COMMAND__=$(command -v python3 || command -v python3.9 || command -v python3.8 || command -v python3.7 || command -v python3.6 || command -v python3.5 || command -v python || echo python)
            __PIP_COMMAND__=$(command -v pip3 || command -v pip3.9 || command -v pip3.8 || command -v pip3.7 || command -v pip3.6 || command -v pip3.5 || command -v pip || echo pip)

            case $2 in
                installed)  "$__PYTHON_COMMAND__" -c "import $3" 2> /dev/null ;;
                *) die "python_module is $2: not support."
            esac
            ;;
        get)
            [ $# -eq 3 ] || die "[python_module get] command accept 2 arguments."

            handle_dependency required exe python3:python3.9:python3.8:python3.7:python3.6:python3.5:python
            handle_dependency required exe pip3:pip3.9:pip3.8:pip3.7:pip3.6:pip3.5:pip

            __PYTHON_COMMAND__=$(command -v python3 || command -v python3.9 || command -v python3.8 || command -v python3.7 || command -v python3.6 || command -v python3.5 || command -v python || echo python)
            __PIP_COMMAND__=$(command -v pip3 || command -v pip3.9 || command -v pip3.8 || command -v pip3.7 || command -v pip3.6 || command -v pip3.5 || command -v pip || echo pip)

            case $2 in
                version)  "$__PIP_COMMAND__" show "$3" 2> /dev/null | grep 'Version:'  | cut -d ' ' -f2 ;;
                location) "$__PIP_COMMAND__" show "$3" 2> /dev/null | grep 'Location:' | cut -d ' ' -f2 ;;
                *) die "python_module get $2: not support."
            esac
            ;;
        install)
            if [ -z "$2" ] ; then
                die "please specify a python module name."
            fi
            if ! python_module is installed "$2" ; then
                print "ðŸ”¥  ${COLOR_GREEN}$2${COLOR_OFF} ${COLOR_YELLOW}python module is required, but it is not found, I will install it via${COLOR_OFF} ${COLOR_GREEN}$__PIP_COMMAND__${COLOR_OFF}\n"
                run "$__PIP_COMMAND__" install -U pip  || return 1
                run "$__PIP_COMMAND__" install -U "$2" || return 1
            fi
            ;;
        *)  die "python_module $1: not support."
    esac
}

# }}}
##############################################################################
# {{{ perl_module

# examples:
# perl_module is  installed libxml2
# perl_module get version   libxml2
# perl_module get location  libxml2
# perl_module install       libxml2
perl_module() {
    case $1 in
        is)
            [ $# -eq 4 ] || die "perl_module command accept 4 arguments."
            handle_dependency required exe perl
            case $2 in
                installed)  perl -M"$3" -le 'print "installed"' > /dev/null 2>&1 ;;
                *) die "perl_module is $2: not support."
            esac
            ;;
        get)
            ;;
        install)
            if ! perl_module is installed "$3" ; then
                handle_dependency required exe cpan:cpanm
                if   command_exists_in_filesystem cpan  ; then
                    cpan -i "$3"
                elif command_exists_in_filesystem cpanm ; then
                    cpanm "$3"
                else
                    die "no perl module installer found."
                fi
            fi
            ;;
        *)  die "perl_module $1: not support."
    esac
}

# }}}
##############################################################################
# {{{ encode/decode dependency

__encode_dependency() {
    if [ $# -eq 0 ] ; then
        tr ' ' '|'
    else
        printf "%s" "$*" | tr ' ' '|'
    fi
}

__decode_dependency() {
    if [ $# -eq 0 ] ; then
        tr '|' ' '
    else
        printf "%s" "$*" | tr '|' ' '
    fi
}

# }}}
##############################################################################
# {{{ regist dependency

# regist dependency required|optional exe|lib|dev|py|pm|pip|npm|gem|pub|cargo|go NAME
#
# required this is a required dependency
# optional this is a optional dependency
#
# exe  this dependency is a command
# py   this dependency is a python  module
# py2  this dependency is a python2 module
# py3  this dependency is a python3 module
# pm   this dependency is a perl module
#
# gt VERSION
# ge VERSION
# lt VERSION
# le VERSION
# eq VERSION
# ne VERSION
#
# examples:
# regist_dependency required exe pkg-config ge 0.18
# regist_dependency required exe python     ge 3.5
# regist_dependency required py  libxml2    ge 2.19
#
# regist_dependency optional exe pkg-config ge 0.18
# regist_dependency optional exe python     ge 3.5
# regist_dependency optional py  libxml2    ge 2.19
regist_dependency() {
    case $1 in
        required)
            if [ -z "$REQUIRED_DEPENDENCY_LIST" ] ; then
                REQUIRED_DEPENDENCY_LIST="$(__encode_dependency "$*")"
            else
                REQUIRED_DEPENDENCY_LIST="$REQUIRED_DEPENDENCY_LIST $(__encode_dependency "$*")"
            fi
            ;;
        optional)
            if [ -z "$OPTIONAL_DEPENDENCY_LIST" ] ; then
                OPTIONAL_DEPENDENCY_LIST=$(__encode_dependency "$*")
            else
                OPTIONAL_DEPENDENCY_LIST="$OPTIONAL_DEPENDENCY_LIST $(__encode_dependency "$*")"
            fi
    esac
}

# }}}
##############################################################################
# {{{ define formula syntax

# set package informations
# 
# examples:
# package set|add summary "JPEG image codec that aids compression and decompression"
# package set|add webpage "https://www.libjpeg-turbo.org"
# package set|add src.git "https://github.com/libjpeg-turbo/libjpeg-turbo.git"
# package set|add src.url "https://downloads.sourceforge.net/project/libjpeg-turbo/2.0.6/libjpeg-turbo-2.0.6.tar.gz"
# package set|add src.sum "d74b92ac33b0e3657123ddcf6728788c90dc84dcb6a52013d758af3c4af481bb"
# package set|add license "IJG"
# package set|add dep.cmd "nasm"
# package set|add dep.pkg "libxx"
# package set|add bsystem "cmake"
# package set     binsrcd 'YES|NO'
# package set     sourced 'src'
# package set     sdk.api '23'
#
# package get PACKAGE KEY
package() {
    unset __PACKAGE_KEY__

    if [ $# -lt 2 ] ; then
        die "package <set|add|get> <key> [value]..."
    fi
    if [ -z "$2" ] ; then
        die "key can not be empty."
    fi
    case $1 in
        set)
            shift
            __PACKAGE_KEY__="$1"
            shift
            __PACKAGE_KEY__="$(echo "$__PACKAGE_KEY__" | tr - _  | tr . _ | tr a-z A-Z)"
            eval "PACKAGE_$__PACKAGE_KEY__=\"$@\"" || exit 1
            ;;
        get)
            shift
            __load_formula_of_the_given_package "$1"
            shift
            __PACKAGE_KEY__="$(echo "$1" | tr - _  | tr . _ | tr a-z A-Z)"
            eval echo \$PACKAGE_$__PACKAGE_KEY__ || exit 1
            ;;
        add)
            shift
            __PACKAGE_KEY__="$1"
            shift
            __PACKAGE_KEY__="$(echo "$__PACKAGE_KEY__" | tr - _  | tr . _ | tr a-z A-Z)"
            __PACKAGE_VAL__="$(eval echo \$PACKAGE_$__PACKAGE_KEY__)"
            eval "PACKAGE_$__PACKAGE_KEY__=\"$__PACKAGE_VAL__ $@\"" || exit 1
            ;;
        '') die "operation can not be empty." ;;
        *)  die "$1: operation not support "
    esac
}

__parse_require_command_item() {
    case $1 in
        *\<=*) echo "required exe $1" | sed 's/<=/ le /g' ;;
        *\>=*) echo "required exe $1" | sed 's/>=/ ge /g' ;;
        *=*)   echo "required exe $1" | sed 's/<=/ eq /g' ;;
        *\<*)  echo "required exe $1" | sed 's/<=/ lt /g' ;;
        *\>*)  echo "required exe $1" | sed 's/<=/ gt /g' ;;
        *)     echo "required exe $1"
    esac
}

__parse_require_python_module_item() {
    case $1 in
        *\<=*) echo "required py $1" | sed 's/<=/ le /g' ;;
        *\>=*) echo "required py $1" | sed 's/>=/ ge /g' ;;
        *=*)   echo "required py $1" | sed 's/<=/ eq /g' ;;
        *\<*)  echo "required py $1" | sed 's/<=/ lt /g' ;;
        *\>*)  echo "required py $1" | sed 's/<=/ gt /g' ;;
        *)     echo "required py $1"
    esac
}

__parse_require_perl_module_item() {
    case $1 in
        *\<=*) echo "required pm $1" | sed 's/<=/ le /g' ;;
        *\>=*) echo "required pm $1" | sed 's/>=/ ge /g' ;;
        *=*)   echo "required pm $1" | sed 's/<=/ eq /g' ;;
        *\<*)  echo "required pm $1" | sed 's/<=/ lt /g' ;;
        *\>*)  echo "required pm $1" | sed 's/<=/ gt /g' ;;
        *)     echo "required pm $1"
    esac
}

__parse_package_patches() {
    if [ $# -lt 2 ] ; then
        die "the number of arguments of patches command at least 2."
    fi

    if [ $(expr $# % 2) -eq 1 ] ; then
        die "the number of arguments of patches command must be even integer."
    fi

    while [ -n "$1" ]
    do
        case $1 in
            *.diff)    PATCH_CONTENT_TYPE=patch  ; package add dep.cmd patch           ;;
            *.patch)   PATCH_CONTENT_TYPE=patch  ; package add dep.cmd patch           ;;
            *.zip)     PATCH_CONTENT_TYPE=zip    ; package add dep.cmd patch unzip     ;;
            *.tar.xz)  PATCH_CONTENT_TYPE=tar.xz ; package add dep.cmd patch tar xz    ;;
            *.tar.gz)  PATCH_CONTENT_TYPE=tar.gz ; package add dep.cmd patch tar gzip  ;;
            *.tar.lz)  PATCH_CONTENT_TYPE=tar.lz ; package add dep.cmd patch tar lzip  ;;
            *.tar.bz2) PATCH_CONTENT_TYPE=tar.bz2; package add dep.cmd patch tar bzip2 ;;
            *.tgz)     PATCH_CONTENT_TYPE=tar.gz ; package add dep.cmd patch tar gzip  ;;
            *.txz)     PATCH_CONTENT_TYPE=tar.xz ; package add dep.cmd patch tar xz    ;;
            *)  die "unrecognized extension : $1. the supported extensions are .diff .patch .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
        esac

        [ ${#2} -eq 64 ] || die "$2 is not sha256sum. the length of sha256sum must be 64."

        shift 2
    done
}

# }}}
##############################################################################
# {{{ operations of formula

__load_formula_of_the_given_package() {
    die_if_package_is_not_available "$1"

    unset PACKAGE_NAME
    unset PACKAGE_SUMMARY
    unset PACKAGE_WEBPAGE
    unset PACKAGE_SRC_GIT
    unset PACKAGE_SRC_URL
    unset PACKAGE_SRC_SUM
    unset PACKAGE_SRC_NAME
    unset PACKAGE_SRC_PATH
    unset PACKAGE_SRC_TYPE
    unset PACKAGE_VERSION
    unset PACKAGE_LICENSE
    unset PACKAGE_PATCHES

    # relative to $WORKING_DIR, which contains build script such as configure, Makefile, CMakeLists.txt, meson.build, Cargo.toml, etc.
    unset PACKAGE_SOURCED

    unset PACKAGE_BSYSTEM
    unset PACKAGE_BINSRCD

    unset PACKAGE_BUILD_SYSTEM

    # if build in source dir, otherwise in build dir
    unset PACKAGE_BUILD_IN_SOURCE_DIR

    # if build in parallel
    unset PACKAGE_BUILD_IN_PARALLEL

    # dependency commands
    unset PACKAGE_DEP_CMD

    # dependency python modules
    unset PACKAGE_DEP_PIP

    # dependency packages
    unset PACKAGE_DEP_PKG

    unset PACKAGE_CDEFINE
    unset PACKAGE_CCFLAGS
    unset PACKAGE_XXFLAGS
    unset PACKAGE_LDFLAGS

    unset PACKAGE_FORMULA_FILEPATH

    unset PACKAGE_SDK_API

    unset -f build0
    unset -f prepare
    unset -f build
    unset -f build_configed

    PACKAGE_NAME="$1"

    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)"

    if [ -z "$PACKAGE_FORMULA_FILEPATH" ] ; then
        die "$1 package's formula is not found."
    fi

    . "$PACKAGE_FORMULA_FILEPATH" || die "$PACKAGE_FORMULA_FILEPATH is broken."

    PACKAGE_BUILD_SYSTEM=$PACKAGE_BSYSTEM
    PACKAGE_BUILD_IN_SOURCE_DIR=$PACKAGE_BINSRCD

    if [ -z "$PACKAGE_SUMMARY" ] ; then
        die "summary must be configed in $PACKAGE_FORMULA_FILEPATH"
    fi

    if [ -z "$PACKAGE_WEBPAGE" ] ; then
        PACKAGE_WEBPAGE="$PACKAGE_SRC_GIT"
    fi

    if [ -z "$PACKAGE_WEBPAGE" ] ; then
        die "webpage or src.git must be configed in $PACKAGE_FORMULA_FILEPATH"
    fi

    if [ -z "$PACKAGE_SRC_URL" ] ; then
        PACKAGE_SRC_URL="$PACKAGE_SRC_GIT"
    fi

    if [ -z "$PACKAGE_SRC_URL" ] ; then
        die "src.url or src.git must be configed in $PACKAGE_FORMULA_FILEPATH"
    fi

    case $PACKAGE_SRC_URL in
        dir://*)   PACKAGE_SRC_TYPE=dir ;;
        *.git)     PACKAGE_SRC_TYPE=git    ; package add dep.cmd git ;;
        *.zip)     PACKAGE_SRC_TYPE=zip    ; package add dep.cmd curl unzip ;;
        *.tar.xz)  PACKAGE_SRC_TYPE=tar.xz ; package add dep.cmd curl tar xz ;;
        *.tar.gz)  PACKAGE_SRC_TYPE=tar.gz ; package add dep.cmd curl tar gzip ;;
        *.tar.lz)  PACKAGE_SRC_TYPE=tar.lz ; package add dep.cmd curl tar lzip ;;
        *.tar.bz2) PACKAGE_SRC_TYPE=tar.bz2; package add dep.cmd curl tar bzip2 ;;
        *.tgz)     PACKAGE_SRC_TYPE=tar.gz ; package add dep.cmd curl tar gzip ;;
        *.txz)     PACKAGE_SRC_TYPE=tar.xz ; package add dep.cmd curl tar xz ;;
        *.c)       PACKAGE_SRC_TYPE=c      ; package add dep.cmd curl ;;
        *.cc)      PACKAGE_SRC_TYPE=cxx    ; package add dep.cmd curl ;;
        *.cxx)     PACKAGE_SRC_TYPE=cxx    ; package add dep.cmd curl ;;
        *.cpp)     PACKAGE_SRC_TYPE=cxx    ; package add dep.cmd curl ;;
        *)  die "unrecognized extension : $PACKAGE_SRC_URL. the supported extensions are .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    case $PACKAGE_SRC_TYPE in
        dir)
            if command -v cut > /dev/null ; then
                PACKAGE_SRC_PATH=$(echo $PACKAGE_SRC_URL | cut -c7-${#PACKAGE_SRC_URL})
            elif command -v awk > /dev/null ; then
                PACKAGE_SRC_PATH=$(echo $PACKAGE_SRC_URL | awk '{print(substr($0, 7))}')
            else
                PACKAGE_SRC_PATH=$(expr substr "$PACKAGE_SRC_URL" 7 ${#PACKAGE_SRC_URL})
            fi
            [ -d "$PACKAGE_SRC_PATH" ] || die "src.url point to dir is not exist."
            ;;
        git)
            PACKAGE_SRC_NAME="$PACKAGE_NAME.git"
            PACKAGE_SRC_PATH="$MY_SOURCE_DIR/$PACKAGE_SRC_NAME"
            ;;
        *)
            if [ -z "$PACKAGE_SRC_SUM" ] ; then
                die "src.sum is not configed in $PACKAGE_FORMULA_FILEPATH"
            fi
            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(basename "$PACKAGE_SRC_URL" | tr _ - | sed 's|-stable||' | sed 's|-src||' | sed 's|\.src||' | sed 's|\.orig\.|.|' | awk '{str = tolower($0); gsub(".tar.xz", "", str); gsub(".tar.gz", "", str); gsub(".tar.lz", "", str); gsub(".tar.bz2", "", str); gsub(".tgz", "", str); gsub(".txz", "", str); gsub(".zip", "", str); print(str)}' | awk -F- '{print $NF}')"
                if [ -z "$PACKAGE_VERSION" ] ; then
                    die "version is not configed in $PACKAGE_FORMULA_FILEPATH"
                else
                    case $PACKAGE_VERSION in
                        v*) if command -v cut > /dev/null ; then
                                PACKAGE_VERSION=$(echo $PACKAGE_VERSION | cut -c2-${#PACKAGE_VERSION})
                            elif command -v awk > /dev/null ; then
                                PACKAGE_VERSION=$(echo $PACKAGE_VERSION | awk '{print(substr($0, 2))}')
                            else
                                PACKAGE_VERSION=$(expr substr "$PACKAGE_VERSION" 2 ${#PACKAGE_VERSION})
                            fi
                    esac
                fi
            fi
            PACKAGE_SRC_NAME="$PACKAGE_NAME-$PACKAGE_VERSION.$PACKAGE_SRC_TYPE"
            PACKAGE_SRC_PATH="$MY_SOURCE_DIR/$PACKAGE_SRC_NAME"
    esac

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            autogen)     package add dep.cmd perl m4 autoconf automake make ;;
            autotools)   package add dep.cmd perl m4 autoconf automake make ;;
            configure)   package add dep.cmd make ;;
            ndk-build)   package add dep.cmd make ;;
            cmake)       package add dep.cmd 'cmake>=3.10' make  ;;
            cmake-make)  package add dep.cmd 'cmake>=3.10' make  ;;
            cmake-ninja) package add dep.cmd 'cmake>=3.10' ninja ;;
            meson)       package add dep.cmd meson ninja ;;
            make)        package add dep.cmd make  ;;
            ninja)       package add dep.cmd ninja ;;
            cargo)       package add dep.cmd rustup cargo ;;
            go)          package add dep.cmd go ;;
        esac
    done

    if [ -n "$PACKAGE_PATCHES" ] ; then
        __parse_package_patches $PACKAGE_PATCHES
    fi

    if [ "$PACKAGE_BUILD_IN_PARALLEL" = NO ] ; then
        NJOBS=1
    fi

    if [ "$PACKAGE_BUILD_SYSTEM" = 'go' ] ; then
        PACKAGE_BINSRCD=YES
        PACKAGE_BUILD_IN_SOURCE_DIR=YES
    fi

    package add dep.cmd 'tree'

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
        package add dep.cmd 'gsed'
    fi

    package add dep.cmd 'find'
}

# examples:
# __view_formula_of_the_given_package curl
# __view_formula_of_the_given_package curl --paging=never
__view_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)"

    if [ -z "$PACKAGE_FORMULA_FILEPATH" ] ; then
        die "$1 package is not available."
    fi

    shift

    unset VIEW_FORMULA_PAGING

    while [ -n "$1" ]
    do
        case $1 in
            --paging=*)
                VIEW_FORMULA_PAGING=$(getvalue "$1")
                case $VIEW_FORMULA_PAGING in
                    auto|always|never) ;;
                    *) die "--paging=VALUE VALUE must be one of auto, always, never"
                esac
                ;;
            *)  die "unrecognized argument: $1"
        esac
        shift
    done

    case $VIEW_FORMULA_PAGING in
        ''|auto)
            if command -v bat > /dev/null ; then
                bat --paging=auto "$PACKAGE_FORMULA_FILEPATH"
            else
                cat "$PACKAGE_FORMULA_FILEPATH"
                echo
                prompt_user_to_install_bat
            fi
            ;;
        always)
            if command -v bat > /dev/null ; then
                bat --paging=always "$PACKAGE_FORMULA_FILEPATH"
            else
                more "$PACKAGE_FORMULA_FILEPATH"
                echo
                prompt_user_to_install_bat
            fi
            ;;
        never)
            if command -v bat > /dev/null ; then
                bat --paging=never "$PACKAGE_FORMULA_FILEPATH"
            else
                cat "$PACKAGE_FORMULA_FILEPATH"
                echo
                prompt_user_to_install_bat
            fi
            ;;
    esac
}

__edit_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)"

    if [ -z "$PACKAGE_FORMULA_FILEPATH" ] ; then
        die "$1 package is not available."
    fi

    [ -z "$2" ] || warn "edit action accept only one argument."

    if [ -z "$EDITOR" ] ; then
        EDITOR=$(command -v nvim || command -v vim || command -v vi || command -v open) || die "please set EDITOR environment variable."
    fi

    "$EDITOR" "$PACKAGE_FORMULA_FILEPATH"
}

__create_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    unset REPO_NAME
    REPO_NAME=offical

    if [ -e "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.sh" ] ; then
        die "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.sh formula already exists."
    fi

    cat > "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.sh" <<EOF
package set summary "Summary of this package"

package set webpage "https://www.xx.com"

# the source code download url of this package. the value of src_url must end with one of .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz
package set src.url "https://www.xx.com/pkgname-x.y.z.tar.gz"

# the sha256sum of source code. If the value of src_url end with .git, this function is optional, otherwise, this function must be invoked.
package set src.sum "c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1"

# the version of this package. If this function is not invoked, it will be calculated from src_url.
#package set version "x.y.z"

# the license of this package.
#package set license "MIT"

# the required commands of this package when installing. If specify multiple values, separate them with spaces.
#package set dep.cmd "a b c"

# the packages are depended by this package. If specify multiple values, separate them with spaces.
#package set dep.pkg "a b c"

prepare() {
    :
    #this function is optional, you can delete it, if don't use it.
}

build() {
    :
    #configure
    #cargow
    #mesonw
    #cmakew
    #makew
}
EOF
    __edit_formula_of_the_given_package "$1"
}

__delete_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)"

    if [ -z "$PACKAGE_FORMULA_FILEPATH" ] ; then
        die "$1 package is not available."
    fi

    run rm "$PACKAGE_FORMULA_FILEPATH"
}

__rename_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"
    die_if_package_is_not_specified "$2"

    unset PACKAGE_FORMULA_REPO
    PACKAGE_FORMULA_REPO="$(__repo_of_formula_of_the_given_package $1)"

    if [ -z "$PACKAGE_FORMULA_REPO" ] ; then
        die "$1 package is not available."
    fi

    unset PACKAGE_FORMULA_FILEPATH_OLD
    unset PACKAGE_FORMULA_FILEPATH_NEW

    PACKAGE_FORMULA_FILEPATH_OLD="$MY_FORMULA_REPO_DIR/$PACKAGE_FORMULA_REPO/formula/$1.sh"
    PACKAGE_FORMULA_FILEPATH_NEW="$MY_FORMULA_REPO_DIR/$PACKAGE_FORMULA_REPO/formula/$2.sh"

    if [ -f "$PACKAGE_FORMULA_FILEPATH_NEW" ] ; then
        die "$2 package is already exist."
    fi

    if mv "$PACKAGE_FORMULA_FILEPATH_OLD" "$PACKAGE_FORMULA_FILEPATH_NEW" ; then
        success "rename formula $1 -> $2 success."
    else
        die "rename formula $1 -> $2 failed."
    fi
}

__list_formulas() {
    for repo in $(cut -d= -f1 "$MY_HOME_DIR/repos")
    do
        if [ -d  "$MY_FORMULA_REPO_DIR/$repo/formula" ] ; then
            ls "$MY_FORMULA_REPO_DIR/$repo/formula"/*.sh
        fi
    done
}

# __add_a_formula_repo NAME URL
__add_a_formula_repo() {
    if [ -z "$1" ] ; then
        die "please specify a repo name."
    fi

    if [ -z "$2" ] ; then
        die "please specify a repo url."
    fi

    case $2 in
        *.git)
            case $2 in
                http://*|https://*|git@*) ;;
                *)  die "$2: not a valid git url."
            esac
            ;;
        *)  die "$2: repo url must end with .git"
    esac

    for repoName in $(__list_formula_repositories | cut -d= -f1)
    do
        if [ "$repoName" = "$1" ] ; then
            die "$1 formula repo already exists."
        fi
    done

    echo "$1=$2" >> "$MY_HOME_DIR/repos"
}

# __del_a_formula_repo NAME
__del_a_formula_repo() {
    if [ -z "$1" ] ; then
        die "please specify a repo name."
    fi

    if [ "$1" = 'offical' ] ; then
        die "offical formula repo can not be deleted."
    fi

    unset REPO_EXISTS
    for repoName in $(__list_formula_repositories | cut -d= -f1)
    do
        if [ "$repoName" = "$1" ] ; then
            REPO_EXISTS=YES
        fi
    done
    if [ "$REPO_EXISTS" = YES ] ; then
        sed_in_place "/^$1=/d" "$MY_HOME_DIR/repos"
    else
        die "$1 formula repo not exists."
    fi
}

__repo_of_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    for repo in $(__list_formula_repositories | cut -d= -f1)
    do
        if [ -e "$MY_FORMULA_REPO_DIR/$repo/formula/$1.sh" ] ; then
            echo "$repo"
            return 0
        fi
    done

    return 1
}

__path_of_formula_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    for repo in $(cut -d= -f1 "$MY_HOME_DIR/repos")
    do
        if [ -e  "$MY_FORMULA_REPO_DIR/$repo/formula/$1.sh" ] ; then
            echo "$MY_FORMULA_REPO_DIR/$repo/formula/$1.sh"
            return 0
        fi
    done
}

__list_formula_repositories() {
    if [ -e "$MY_HOME_DIR/repos" ] ; then
        cat "$MY_HOME_DIR/repos"
    else
        install -d "$MY_HOME_DIR"
        echo "offical=$MY_OFFICAL_FORMULA_REPO_URL" | tee "$MY_HOME_DIR/repos"
    fi
}

__update_formula_repositories() {
    set -e

    handle_dependency required exe git

    for repo in $(__list_formula_repositories)
    do
        unset MY_FORMULA_REPO_NAME
        unset MY_FORMULA_REPO_URL_

        MY_FORMULA_REPO_NAME=$(echo "$repo" | cut -d= -f1)
        MY_FORMULA_REPO_URL_=$(echo "$repo" | cut -d= -f2)

        info "=== Updating repository ${COLOR_GREEN}$MY_FORMULA_REPO_NAME${COLOR_OFF}"
        fetch "$MY_FORMULA_REPO_URL_" --output-dir="$MY_FORMULA_REPO_DIR" --output-name="$MY_FORMULA_REPO_NAME"
    done
}

# }}}
##############################################################################

prompt_user_to_install_bat() {
    echo "${COLOR_YELLOW}Note: if you want to have a better experience, I strongly recommend you to install${COLOR_OFF} ${COLOR_GREEN}bat${COLOR_OFF} ${COLOR_YELLOW}on your os. For more details, please visit website${COLOR_OFF} ${COLOR_GREEN}https://github.com/sharkdp/bat${COLOR_OFF}"
}

__fetch_sources_of_the_given_package() {
    # fetch source code if needed
    if [ "$PACKAGE_SRC_TYPE" != 'dir' ] ; then
        fetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SUM" --output-path="$PACKAGE_SRC_PATH"
    fi
}

__fetch_patches_of_the_given_package() {
    unset PACKAGE_PATCHES

    # fetch patches if posible
    while [ -n "$1" ]
    do
        fetch "$1" --sha256="$2" --output-dir="$MY_PATCH__DIR/$PACKAGE_NAME" --output-name="$(basename $1)"

        if [ -z "$PACKAGE_PATCHES" ] ; then
            PACKAGE_PATCHES="$FETCH_OUTPUT_PATH"
        else
            PACKAGE_PATCHES="$PACKAGE_PATCHES $FETCH_OUTPUT_PATH"
        fi

        shift 2
    done
}

__fetch_resources_of_the_given_package() {
    __fetch_sources_of_the_given_package &&
    __fetch_patches_of_the_given_package $PACKAGE_PATCHES
}

die_if_package_is_not_specified() {
    [ -n "$1" ] || die "no package is specified."
}

die_if_package_is_not_available() {
    is_package_available "$1" || die "$1 is not available."
}

die_if_package_is_not_installed() {
    is_package_installed "$1" || die "$1 is not installed."
}

# check if the given package is available
# if the version condition is given, check if the condition is matched
#
# condition operator:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# is_package_available automake eq 1.16.0
# is_package_available automake lt 1.16.0
# is_package_available automake gt 1.16.0
# is_package_available automake le 1.16.0
# is_package_available automake ge 1.16.0
# is_package_available automake
is_package_available() {
    case $# in
        0)  die_if_package_is_not_specified ;;
        1)  [ -n "$(__path_of_formula_of_the_given_package $1)" ] ;;
        3)  __load_formula_of_the_given_package "$1"
            shift
            version_match $PACKAGE_VERSION $@
            ;;
        *)  die "is available command only accept 1 or 3 argument."
    esac
}

is_package_installed() {
    die_if_package_is_not_specified "$1"

    [ -d "$MY_INSTALL_DIR/$1" ]                    || return 1
    [ -f "$MY_INSTALL_DIR/$1/installed-metadata" ] || return 1
    [ -f "$MY_INSTALL_DIR/$1/installed-files" ]    || return 1
    [ -f "$MY_INSTALL_DIR/$1/installed-abis" ]     || return 1
}

is_package__outdated() {
    __load_formula_of_the_given_package "$1"

    __load_installed_metadata_of_the_given_package "$1"

    version_match "$PACKAGE_VERSION" gt "$INSTALLED_PKG_VERS"
}

__gen_github_workflows() {
    set -e

    unset BREAK
    unset NDEPENDED_PACKAGES
    unset AVAILABLE_PACKAGES
    unset GROUP_SIZE
    unset OUTPUT_DIR
    unset I

    while [ -n "$1" ]
    do
        case $1 in
            --group-size=*)
                GROUP_SIZE=$(getvalue "$1")
                is_integer "$GROUP_SIZE" || die "--group-size=INTEGER"
                ;;
            --output-dir=*)
                OUTPUT_DIR=$(getvalue "$1")
                case "$OUTPUT_DIR" in
                    '') die "--output-dir=DIR, DIR must not be empty." ;;
                    /*) ;;
                    \~|\~/) OUTPUT_DIR="${HOME}" ;;
                    \~/*)   OUTPUT_DIR="${HOME}$(printf "$OUTPUT_DIR" | awk '{print(substr($0, 2))}')" ;;
                    .|./)   OUTPUT_DIR="${PWD}" ;;
                    *)      OUTPUT_DIR="${PWD}/$OUTPUT_DIR" ;;
                esac
                [ -d "$OUTPUT_DIR" ] || run install -d "$OUTPUT_DIR"
        esac
        shift
    done

    if [ -z "$GROUP_SIZE" ] ; then
        die "please sepecify --group-size=INTEGER argument."
    fi

    if [ -z "$OUTPUT_DIR" ] ; then
        OUTPUT_DIR="$MY_HOME_DIR/repos.d/offical/.github/workflows"
    fi

    GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH="$MY_HOME_DIR/repos.d/offical/.github/workflows/template"

    if [ ! -f "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" ] ; then
        __update_formula_repositories
    fi

    AVAILABLE_PACKAGES=$(__list_available_packages)

    for x in $AVAILABLE_PACKAGES
    do
        if [ "$x" = 'test' ] ; then
            continue
        fi
        for y in $AVAILABLE_PACKAGES
        do
            if [ "$x" = "$y" ] || [ 'test' = "$y" ] ; then
                continue
            else
                for z in $(get_direct_dependency_package_list_of_the_given_package "$y")
                do
                    if [ "$x" = "$z" ] ; then
                        BREAK=YES
                        break 2
                    fi
                done
            fi
        done
        if [ "$BREAK" = YES ] ; then
            unset BREAK
        else
            if [ -z "$NDEPENDED_PACKAGES" ] ; then
                NDEPENDED_PACKAGES="$x"
            else
                NDEPENDED_PACKAGES="$NDEPENDED_PACKAGES $x"
            fi
            if [ "$(list_length $NDEPENDED_PACKAGES)" -eq "$GROUP_SIZE" ] ; then
                unset OUTPUT_FILEPATH

                I=$(expr ${I-0} + 1)
                OUTPUT_FILEPATH="$OUTPUT_DIR/ci$I.yml"
                NDEPENDED_PACKAGES=$(echo "$NDEPENDED_PACKAGES" | tr ' ' ,)

                echo
                run cp "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" "$OUTPUT_FILEPATH"
                sed_in_place "s/INDEX/$I/"                     "$OUTPUT_FILEPATH"
                sed_in_place "s/PKGLIST/$NDEPENDED_PACKAGES/"  "$OUTPUT_FILEPATH"

                unset NDEPENDED_PACKAGES
            fi
        fi
    done
    if [ -n "$NDEPENDED_PACKAGES" ] ; then
        unset OUTPUT_FILEPATH

        I=$(expr ${I-0} + 1)
        OUTPUT_FILEPATH="$OUTPUT_DIR/ci$I.yml"
        NDEPENDED_PACKAGES=$(echo "$NDEPENDED_PACKAGES" | tr ' ' ,)

        run cp "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" "$OUTPUT_FILEPATH"
        sed_in_place "s/INDEX/$I/"                     "$OUTPUT_FILEPATH"
        sed_in_place "s/PKGLIST/$NDEPENDED_PACKAGES/"  "$OUTPUT_FILEPATH"
    fi
}

__list_available_packages() {
    for repo in $(__list_formula_repositories | cut -d= -f1)
    do
        cd "$MY_FORMULA_REPO_DIR/$repo/formula" || return 1
        ls -1 *.sh | sed 's/\.sh//g' || return 1
    done
}

__list_installed_packages() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
         cd "$MY_INSTALL_DIR" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in *
    do
        if is_package_installed "$packageName" ; then
            echo "$packageName"
        fi
    done
}

__list__outdated_packages() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
         cd "$MY_INSTALL_DIR" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in *
    do
        is_package_available "$packageName" || continue
        is_package_installed "$packageName" || continue
        is_package__outdated "$packageName" || continue
        echo "$packageName"
    done
}

__tree_the_given_installed_package() {
    die_if_package_is_not_installed "$1"
    handle_dependency required exe tree
    run tree $(shiftn 1 $@) "$MY_INSTALL_DIR/$1"
}

__uninstall_the_given_packages() {
    shift

    die_if_package_is_not_specified "$1"
    
    for packageName in $@
    do
        __uninstall_the_given_package "$packageName" || return 1
    done
}

__uninstall_the_given_package() {
    die_if_package_is_not_installed "$1"

    run rm -rf "$MY_INSTALL_DIR/$1"
}

__reinstall_the_given_packages() {
    inspect_build_toolchains

    inspect_install_arguments $@

    die_if_package_is_not_specified $USER_SPECIFIED_PACKAGE_LIST

    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        die_if_package_is_not_available "$packageName"
        die_if_package_is_not_installed "$packageName"
    done

    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        {
            [ -d "$MY_BACKUP_DIR" ] || mkdir -p "$MY_BACKUP_DIR"
        } &&
        mv "$MY_INSTALL_DIR/$packageName" "$MY_BACKUP_DIR/$packageName" &&
        __install_the_given_package "$packageName" &&
        rm -rf "$MY_BACKUP_DIR/$packageName"
    done
}

__upgrade_packages() {
    inspect_build_toolchains

    inspect_install_arguments $@

    if [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] ; then
        USER_SPECIFIED_PACKAGE_LIST=$(__list__outdated_packages)
    fi

    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        die_if_package_is_not_available "$packageName"
        die_if_package_is_not_installed "$packageName"
    done

    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        {
            [ -d "$MY_BACKUP_DIR" ] || mkdir -p "$MY_BACKUP_DIR"
        } &&
        mv "$MY_INSTALL_DIR/$packageName" "$MY_BACKUP_DIR/$packageName" &&
        __install_the_given_package "$packageName" &&
        rm -rf "$MY_BACKUP_DIR/$packageName"
    done
}

__cleanup() {
    [ -d "$MY_SOURCE_DIR" ] || return 0
    for repo in $(__list_formula_repositories | cut -d= -f1)
    do
        cd "$MY_FORMULA_REPO_DIR/$repo/formula" || return 1
        for item in $(ls)
        do
            if [ -f "$item" ] ; then
                case $item in
                    *.sh)
                        __load_formula_of_the_given_package $(echo "$item" | sed 's/\.sh//g')
                esac
            fi
        done
    done
    success "Done."
}

__search_packages() {
    if [ -z "$1" ] ; then
        die "please specify a keyword."
    fi

    for repo in $(__list_formula_repositories | cut -d= -f1)
    do
        cd "$MY_FORMULA_REPO_DIR/$repo/formula" && ls -1 *.sh | sed 's/\.sh//g' | grep "$*"
    done
}

__show_or_open_homepage_of_the_given_package() {
    unset ACTION
    unset PACKAGE

    while [ -n "$1" ]
    do
        case $1 in
            --open)
                ACTION=open
                ;;
            -*|--*)
                die "unrecognized argument: 41"
                ;;
            *)  if [ -z "$PACKAGE" ] ; then
                    PACKAGE=$1
                else
                    die "too many packages given."
                fi
        esac
        shift
    done

    if [ "$ACTION" = open ] ; then
        __open_homepage_of_the_given_package $PACKAGE
    else
        __show_homepage_of_the_given_package $PACKAGE
    fi
}

__show_homepage_of_the_given_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEBPAGE="$MY_HOME_PAGE"
    else
        __load_formula_of_the_given_package "$1"
    fi

    echo "$PACKAGE_WEBPAGE"
}

__open_homepage_of_the_given_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEBPAGE="$MY_HOME_PAGE"
    else
        __load_formula_of_the_given_package "$1"
    fi
    
    if command -v open > /dev/null ; then
        run "open '$PACKAGE_WEBPAGE'"
    elif command -v termux-open-url > /dev/null ; then
        run "termux-open-url '$PACKAGE_WEBPAGE'"
    else
        warn "I don't konw how to open"
    fi
}

__show_depends_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    __gen_dependency_tree_of_the_given_package "$1"

    if [ -f "$DEPENDENCIES_TXT" ] ; then
        cat "$DEPENDENCIES_TXT"
    elif [ -f "$DEPENDENCIES_PNG" ] ; then
        for item in open feh eog lsix
        do
            if command -v $item > /dev/null && $item "$DEPENDENCIES_PNG" ; then
                return 0
            fi
        done
    elif [ -f "$DEPENDENCIES__GV" ] ; then
        cat "$DEPENDENCIES__GV"
    fi
}

# if $1 is     given, show installed directory of the given package.
# if $1 is not given, show this software's home direcotory.
__show_prefix() {
    if [ -z "$1" ] ; then
        echo "$MY_HOME_DIR"
    else
        die_if_package_is_not_installed "$1"
        echo "$MY_INSTALL_DIR/$1"
    fi
}

__logs_the_given_installed_package() {
    die_if_package_is_not_installed "$1"

    if [ -z "$2" ] ; then
        die "please specify a abi."
    fi

    for ABI in $(cat "$MY_INSTALL_DIR/$1/installed-abis")
    do
        if [ "$ABI" = "$2" ] ; then
            break
        else
            unset ABI
        fi
    done

    if [ -z "$ABI" ] ; then
        die "unsupported abi: $1"
    fi

    if command -v bat > /dev/null ; then
        VIEWER=bat
    else
        VIEWER=less
    fi

    __logs_the_given_dir() {
        for item in $(ls "$1")
        do
            item="$1/$item"
            if [ -d "$item" ] ; then
                continue
            fi
            if [ "$VIEWER" = 'bat' ] ; then
                case $item in
                    *.png) ;;
                    *.sh|*/installed-metadata)
                        bat -l bash "$item" ;;
                    *)  bat "$item"
                esac
            else
                "$VIEWER" "$item"
            fi
        done
    }

    __logs_the_given_dir "$MY_INSTALL_DIR/$1"
    __logs_the_given_dir "$MY_INSTALL_DIR/$1/$2/share/log"

    if [ "$VIEWER" != 'bat' ] ; then
        prompt_user_to_install_bat
    fi
}

# examples:
# __pack_the_given_installed_package autoconf
# __pack_the_given_installed_package autoconf --type=tar.xz
__pack_the_given_installed_package() {
    set -e

    __load_installed_metadata_of_the_given_package "$1"

    shift

    unset PACKED_FILE_SUFFIX

    for arg in $@
    do
        case $arg in
            --type=*)
                PACKED_FILE_SUFFIX=$(getvalue $arg)
                if [ -z "$PACKED_FILE_SUFFIX" ] ; then
                    die "--type=VALUE : VALUE must not be empty."
                fi
                ;;
            *)  die "unrecognized argument: $arg"
        esac
    done

    if [ -z "$PACKED_FILE_SUFFIX" ] ; then
        if command -v 7za > /dev/null ; then
            PACKED_FILE_SUFFIX=7z
        elif command -v zip > /dev/null ; then
            PACKED_FILE_SUFFIX=zip
        elif command -v tar > /dev/null ; then
            if command -v xz > /dev/null ; then
                PACKED_FILE_SUFFIX=tar.xz
            elif command -v bzip2 > /dev/null ; then
                PACKED_FILE_SUFFIX=tar.bz2
            elif command -v gzip > /dev/null ; then
                PACKED_FILE_SUFFIX=tar.gz
            else
                handle_dependency required exe xz
                PACKED_FILE_SUFFIX=tar.xz
            fi
        else
            handle_dependency required exe zip
            PACKED_FILE_SUFFIX=tar.xz
        fi
    else
        case $PACKED_FILE_SUFFIX in
            7z) handle_dependency required exe 7za ;;
            zip)handle_dependency required exe zip ;;
            tar.gz)
                handle_dependency required exe tar
                handle_dependency required exe gzip
                ;;
            tar.xz)
                handle_dependency required exe tar
                handle_dependency required exe xz
                ;;
            tar.bz2)
                handle_dependency required exe tar 
                handle_dependency required exe bzip2 
                ;;
            *) die "unsupported type: $PACKED_FILE_SUFFIX, the supported types are 7z zip tar.gz tar.xz tar.bz2."
        esac
    fi

    unset PACKED_DIR_NAME
    unset PACKED_FILE_NAME

    PACKED_DIR_NAME="$INSTALLED_PKG_NAME-$INSTALLED_PKG_VERS-ndk-pkg-bin"
    PACKED_FILE_NAME="$PACKED_DIR_NAME.$PACKED_FILE_SUFFIX"

    step "create working directory"
    info "mktemp -d"
    WORKING_DIR=$(mktemp -d)

    step "change to working directory"
    run cd $WORKING_DIR

    step "make link refer to installed package root dir"
    run ln -s "$MY_INSTALL_DIR/$INSTALLED_PKG_NAME" "$PACKED_DIR_NAME"

    step "packing"
    case $PACKED_FILE_SUFFIX in
        7z)  run 7za a -t7z -r "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
        zip) run zip -9 -r     "$PACKED_FILE_NAME" "$PACKED_DIR_NAME" ;;
        tar.gz)  run tar zvcf  "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
        tar.xz)  run tar Jvcf  "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
        tar.bz2) run tar jvcf  "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
    esac

    if [ ! -d "$MY_BINARY_DIR" ] ; then
        step "create cached binary dir"
        run install -d "$MY_BINARY_DIR"
    fi

    step "copy packed file to cached binary dir"
    run cp "$PACKED_FILE_NAME" "$MY_BINARY_DIR/"

    step "show disk usage statistics"
    run "du -sh $PACKED_FILE_NAME | cut -f1"

    step "delete working directory"
    run rm -rf $WORKING_DIR
}

get_direct_dependency_package_list_of_the_given_package() {
    grep '^\s*package set dep\.pkg\s*".*"' $(__path_of_formula_of_the_given_package $1) | sed 's/.*package set dep\.pkg.*"\(.*\)"/\1/'
}

# $1 packageName, if packageName is not specified, USER_SPECIFIED_PACKAGE_LIST will be used
# $2=YES invoked by myself
__gen_dependency_list_of_the_given_package() {
    [ "$2" = YES ] || {
        unset I
        unset DEPENDENCY_PACKAGE_LIST
    }

    unset DIRECT_DEPENDENCY_PACKAGE_LIST
    if [ -z "$1" ] ; then
        DIRECT_DEPENDENCY_PACKAGE_LIST="$USER_SPECIFIED_PACKAGE_LIST"
    else
        DIRECT_DEPENDENCY_PACKAGE_LIST=$(get_direct_dependency_package_list_of_the_given_package "$1")
    fi

    for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
    do
        die_if_package_is_not_available "$dependencyPkgName"

        DEPENDENCY_PACKAGE_LIST_TEMP=""

        for item in $DEPENDENCY_PACKAGE_LIST
        do
            if [ "$dependencyPkgName" = "$item" ] ; then
                continue
            else
                DEPENDENCY_PACKAGE_LIST_TEMP="$DEPENDENCY_PACKAGE_LIST_TEMP $item"
            fi
        done

        DEPENDENCY_PACKAGE_LIST="$dependencyPkgName $DEPENDENCY_PACKAGE_LIST_TEMP"

        __gen_dependency_list_of_the_given_package "$dependencyPkgName" YES
    done
}

# __gen_dependency_tree_of_the_given_package PKG [OUTPUT-DIR]
__gen_dependency_tree_of_the_given_package() {
    unset DIRECT_DEPENDENCY_PACKAGE_LIST
    DIRECT_DEPENDENCY_PACKAGE_LIST="$(get_direct_dependency_package_list_of_the_given_package "$1")"

    if [ -z "$DIRECT_DEPENDENCY_PACKAGE_LIST" ] ; then
        return 0
    fi

    unset DEPENDENCIES__GV
    unset DEPENDENCIES_PNG
    unset DEPENDENCIES_TXT

    unset DEPENDENCIES_OUTPUT_DIR

    if [ -z "$2" ] ; then
        DEPENDENCIES_OUTPUT_DIR=$(mktemp -d) || return 1
    else
        DEPENDENCIES_OUTPUT_DIR="$2"
    fi

    DEPENDENCIES__GV="$DEPENDENCIES_OUTPUT_DIR/dependencies.gv"
    DEPENDENCIES_PNG="$DEPENDENCIES_OUTPUT_DIR/dependencies.png"
    DEPENDENCIES_TXT="$DEPENDENCIES_OUTPUT_DIR/dependencies.txt"

    printf 'digraph "%s\n" {' "$1" > "$DEPENDENCIES__GV"

    for dependencyPkgName in $1 $DIRECT_DEPENDENCY_PACKAGE_LIST
    do
        unset DIRECT_DEPENDENCY_PACKAGE_LIST
        DIRECT_DEPENDENCY_PACKAGE_LIST="$(get_direct_dependency_package_list_of_the_given_package "$dependencyPkgName")"
        if [ -z "$DIRECT_DEPENDENCY_PACKAGE_LIST" ] ; then
            continue
        fi
        printf '"%s" -> { "%s" }\n' "$dependencyPkgName" "$(printf '%s\n' "$DIRECT_DEPENDENCY_PACKAGE_LIST" | sed 's/ /" "/g')" >> "$DEPENDENCIES__GV"
    done

    printf "}\n" >> "$DEPENDENCIES__GV"

    if command -v dot > /dev/null ; then
        run dot -Tpng -o "$DEPENDENCIES_PNG" "$DEPENDENCIES__GV"
    else
        warn "graphviz is not installed. we do not generate png format dependency image."
    fi

    # https://github.com/ggerganov/dot-to-ascii
    curl \
        -o "$DEPENDENCIES_TXT" \
        -s \
        -G \
        --data-urlencode "boxart=1" \
        --data-urlencode "src=$(cat $DEPENDENCIES__GV)" \
        "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php" || true
}

__config_global_installation_variables() {
    for tool in $(list_tools_in_the_toolchain)
    do
        unset TOOL_PATH
        case $tool in
            cc)
                if [ -z "$CC" ] ; then
                    TOOL_PATH=$(command -v cc || command -v gcc || command -v clang)
                else
                    TOOL_PATH="$CC"
                fi
                ;;
            cxx)
                if [ -z "$CXX" ] ; then
                    TOOL_PATH=$(command -v c++ || command -v g++ || command -v clang++)
                else
                    TOOL_PATH="$CXX"
                fi
                ;;
            *)  TOOL_PATH=$(command -v "$tool")
        esac

        unset TOOL_UPPER
        TOOL_UPPER=$(echo "$tool" | tr a-z A-Z)

        eval $TOOL_UPPER=$TOOL_PATH
        eval export "${TOOL_UPPER}_FOR_BUILD=\"$TOOL_PATH\""
    done
    unset TOOL_PATH
    unset TOOL_UPPER

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        eval export "${FLAG}_FOR_BUILD=\"\$$FLAG\""
    done
    unset FLAG

    export PATH="$TOOLCHAIN_BIN_DIR:$PATH"

    if [ -d "$MY_HOME_DIR/native" ] ; then
        for item in $(find "$MY_HOME_DIR/native" -maxdepth 1 -type d -name bin)
        do
            export PATH="$item:$PATH"
        done
    fi

    if [ "$DEBUG" = YES ] ; then
        export PKG_CONFIG_DEBUG_SPEW=set
    fi
}

__install_the_given_packages() {
    inspect_build_toolchains

    inspect_install_arguments $@

    die_if_package_is_not_specified $USER_SPECIFIED_PACKAGE_LIST

    __config_global_installation_variables

    __gen_dependency_list_of_the_given_package || return 1

    if [ $(list_length $DEPENDENCY_PACKAGE_LIST) -gt 1 ] ; then
        echo "$COLOR_PURPLE==>$COLOR_OFF to install$COLOR_GREEN $DEPENDENCY_PACKAGE_LIST $COLOR_OFF\n"
    fi

    for INSTALLING_PACKAGE in $DEPENDENCY_PACKAGE_LIST
    do
        if is_package_installed "$INSTALLING_PACKAGE" ; then
            printf "$COLOR_GREEN%-10s$COLOR_OFF already have been installed.\n" "$INSTALLING_PACKAGE"
        else
            echo "${COLOR_PURPLE}=============== Installing ${COLOR_OFF}${COLOR_GREEN}${INSTALLING_PACKAGE}${COLOR_OFF}${COLOR_PURPLE} ===============${COLOR_OFF}"
            __install_the_given_package "$INSTALLING_PACKAGE" || {
                if [ -z "$TARGET_OS_ABI" ] ; then
                    die "install $INSTALLING_PACKAGE failed! you can go to $WORKING_DIR to see see."
                else
                    die "install $INSTALLING_PACKAGE/$TARGET_OS_ABI failed! you can go to $WORKING_DIR to see see."
                fi
            }
        fi
    done
}

__install_the_given_package() {
    # brew install meson
    # Error: The current working directory doesn't exist, cannot proceed.
    # beacuse previous package's working direcotory is deleted.
    cd ~ || return 1

    unset WORKING_DIR
    unset SOURCE_DIR
    unset BUILD_DIR

    unset NATIVE_BUILD_DIR
    unset NATIVE_INSTALL_DIR

    unset TARGET_OS_ABI
    unset CONFIG_XX_UPDATED
    unset STEP_NUM

    step "view formula"
    __view_formula_of_the_given_package "$1" --paging=never

    step "load formula"
    __load_formula_of_the_given_package "$1"

    unset TARGET_OS_VERS
    TARGET_OS_VERS=$(pick_target_os_version "$PACKAGE_SDK_API" "$USER_SPECIFIED_TARGET_OS_VERS") || die "$PACKAGE_NAME supportted min-sdk-api-level is $PACKAGE_SDK_API, but you want is $USER_SPECIFIED_TARGET_OS_VERS"

    step "handle required commands"
    for item in $PACKAGE_DEP_CMD
    do
        handle_dependency $(__parse_require_command_item "$item")
    done
    for item in $PACKAGE_DEP_PIP
    do
        handle_dependency $(__parse_require_python_module_item "$item")
    done

    step "printf required commands"
    __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
    for item in $PACKAGE_DEP_CMD
    do
        printf_dependency $(__parse_require_command_item "$item")
    done
    for item in $PACKAGE_DEP_PIP
    do
        printf_dependency $(__parse_require_python_module_item "$item")
    done

    unset PKG_CONFIG
    unset MESON
    unset CMAKE
    unset GMAKE
    unset NINJA

    PKG_CONFIG=$(command -v pkg-config)
    MESON=$(command -v meson)
    CMAKE=$(command -v cmake)
    GMAKE=$(command -v gmake || command -v make)
    NINJA=$(command -v ninja)

    step "fetch resources if needed"
    __fetch_resources_of_the_given_package "$1" || return 1

    step "create working directory"
    info "mktemp -d"
    WORKING_DIR=$(mktemp -d) || die "create working directory failed."

    step "unpack sources to working directory"
    case $PACKAGE_SRC_URL in
        dir://*|*.git)
            PACKAGE_VERSION=$(cd "$PACKAGE_SRC_PATH" && git log -1 --pretty=format:%h) || return 1
            run cp -r "$PACKAGE_SRC_PATH/." "$WORKING_DIR" || return 1
            ;;
        *.c|*.cc|*.cxx|*.cpp)
            run cp    "$PACKAGE_SRC_PATH"   "$WORKING_DIR" || return 1
            ;;
        *.zip)
            run unzip "$PACKAGE_SRC_PATH" -d "$WORKING_DIR" || return 1
            ;;
        *.tar.xz|*.tar.gz|*.tar.lz|*.tar.bz2|*.tgz|*.txz)
            run tar xf "$PACKAGE_SRC_PATH" -C "$WORKING_DIR" --strip-components 1 || return 1
            ;;
        *)  die "unrecognized extension : $PACKAGE_SRC_URL. the supported extensions are .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    if [ -z "$PACKAGE_SOURCED" ] ; then
        SOURCE_DIR="$WORKING_DIR"
    else
        SOURCE_DIR="$WORKING_DIR/$PACKAGE_SOURCED"
    fi

    step "change to source directory"
    run cd "$SOURCE_DIR" || return 1

    step "list content of source directory"
    run ls -l

    step "build for native"
    if command -v build0 > /dev/null ; then
        NATIVE_BUILD_DIR="$WORKING_DIR/$TIMESTAMP_UNIX/native"
        NATIVE_INSTALL_DIR="$MY_HOME_DIR/native/$PACKAGE_NAME"

        if [ -f "$NATIVE_INSTALL_DIR/version.txt" ] ; then
            if [ "$(cat "$NATIVE_INSTALL_DIR/version.txt")" != "$PACKAGE_VERSION" ] ; then
                warn "build for native already have been done, but not same version. we will remove and rebuild it."
                run rm -rf "$NATIVE_INSTALL_DIR"
            fi
        fi

        if [ -f "$NATIVE_INSTALL_DIR/version.txt" ] ; then
            warn "build for native already have been done, skipped."
        else
            [ "$PACKAGE_BUILD_IN_SOURCE_DIR" = YES ] || {
                run install -d "$NATIVE_BUILD_DIR" || return 1
                run cd    "$NATIVE_BUILD_DIR" || return 1
            }

            printf "%17s = %s\n\n" "PACKAGE_NAME" "$PACKAGE_NAME"

            echo
            echo "       PKG_CONFIG = $PKG_CONFIG"
            echo "            MESON = $MESON"
            echo "            CMAKE = $CMAKE"
            echo "            GMAKE = $GMAKE"
            echo "            NINJA = $NINJA"

            for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
            do
                eval export "$TOOL=\"\$${TOOL}_FOR_BUILD\""
                printf "%17s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
            done

            for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
            do
                eval export "$FLAG=\"\$${FLAG}_FOR_BUILD\""
                printf "\n%17s = " "$FLAG"
                FIRST=YES
                for item in $(eval echo \$$FLAG | tr ':' ' ')
                do
                    if [ "$FIRST" = YES ] ; then
                        FIRST=NO
                        echo "$item"
                    else
                        echo "                    $item"
                    fi
                done
            done
            echo
            printf "\n%17s = " PATH
            FIRST=YES
            for item in $(echo "$PATH" | tr ':' ' ')
            do
                if [ "$FIRST" = YES ] ; then
                    FIRST=NO
                    echo "$item"
                else
                    echo "                    $item"
                fi
            done

            echo
            echo "            NPROC = $NPROC"
            echo "            NJOBS = $NJOBS"
            echo
            echo "      WORKING_DIR = $WORKING_DIR"
            echo "       SOURCE_DIR = $SOURCE_DIR"
            echo " NATIVE_BUILD_DIR = $NATIVE_BUILD_DIR"
            echo " NATIVE_INSTALL_DIR = $NATIVE_INSTALL_DIR"
            echo "                PWD = $PWD"
            echo

            run build0 || return 1

            echo "$PACKAGE_VERSION" > "$NATIVE_INSTALL_DIR/version.txt"

            if [ -d "$NATIVE_INSTALL_DIR/bin" ] ; then
                export PATH="$NATIVE_INSTALL_DIR/bin:$PATH"
            fi
        fi
    else
        warn "no build0  function defined in formula, skipped."
    fi

    step "do some preparation works"
    if command -v prepare > /dev/null ; then
        if [ "$PWD" != "$SOURCE_DIR" ] ; then
            run cd "$SOURCE_DIR" || return 1
        fi
        run prepare || return 1
    else
        case $PACKAGE_BUILD_SYSTEM in
            autogen)
                warn "no prepare function defined in formula."
                run NOCONFIGURE=yes ./autogen.sh    || return 1
                ;;
            autotools)
                warn "no prepare function defined in formula."
                run autoreconf -ivf || return 1
                ;;
            *)  warn "no prepare function defined in formula, skipped."
        esac
    fi

    step "show common include.h"
    if command -v bat > /dev/null ; then
        run bat --style=plain --paging=never "$COMMON_INCLUDE_H_FILEPATH"
    else
        run cat "$COMMON_INCLUDE_H_FILEPATH"
    fi

    step "calculate dependencies"
    unset DEPENDENCY_PACKAGE_LIST
    if [ -z "$PACKAGE_DEP_PKG" ] ; then
        warn "no dependencies."
    else
        __gen_dependency_list_of_the_given_package "$1"              || return 1
        __gen_dependency_tree_of_the_given_package "$1" "$MY_INSTALL_DIR/$1" || return 1
        if [ -f "$DEPENDENCIES_TXT" ] ; then
            cat "$DEPENDENCIES_TXT"
        fi
    fi

    __install_the_given_package_all_builds "$1" || return 1

    step "record installed abis"
    INSTALLED_ABIS_FILEPATH="$MY_INSTALL_DIR/$1/installed-abis"
    echo "-- Installing: $INSTALLED_ABIS_FILEPATH"
    printf '%s\n' "$TARGET_OS_ABI_LIST" > "$INSTALLED_ABIS_FILEPATH"

    step "record installed metadata"
    __record_installed_metadata_of_the_given_package "$1"

    step "record installed files"
    __record_installed_files_of_the_given_package "$1"

    [ "$KEEP_WORKING_DIR" = YES ] || {
        step "clean working directory."
        run rm -rf "$WORKING_DIR"
    }

    echo
    success "$1 have been installed successfully."

    if [ "$NEED_RUN_TREE" = YES ] ; then
        unset STEP_NUM
        echo
        echo "${COLOR_GREEN}$_0 tree $1 $TREE_ARGS${COLOR_OFF}"
        __tree_the_given_installed_package "$1" $TREE_ARGS
    fi

    if [ "$NEED_RUN_PACK" = YES ] ; then
        unset STEP_NUM
        echo
        echo "${COLOR_GREEN}$_0 pack $1 $PACK_ARGS${COLOR_OFF}"
        __pack_the_given_installed_package "$1" $PACK_ARGS
    fi
}

__install_the_given_package_all_builds() {
    PKG_INSTALL_DIR="$MY_INSTALL_DIR/$1"

    unset BUILD_ROUND_NUM
    unset TARGET_OS_ABI_LIST

    for BUILD in $BUILD_LIST
    do
        BUILD_ROUND_NUM=$(expr ${BUILD_ROUND_NUM-0} + 1)

        TARGET_OS_ABI=$(echo "$BUILD" | cut -d: -f1)

        if [ -z "$TARGET_OS_ABI_LIST" ] ; then
            TARGET_OS_ABI_LIST="$TARGET_OS_ABI"
        else
            TARGET_OS_ABI_LIST=$(printf "%s %s" "$TARGET_OS_ABI_LIST" "$TARGET_OS_ABI")
        fi

        if [ "$DRYRUN" = YES ] ; then
            __config_this_build_variables "$1"
            __printf_this_build_variables "$1"
            if [ -z "$SHELL" ] ; then
                SHELL=$(command -v zsh || command -v bash || command -v sh)
            fi
            exec "$SHELL" || return 1
        else
            (
                BUILD_DIR="$WORKING_DIR/$TIMESTAMP_UNIX/$TARGET_OS_ABI"
                install -d "$BUILD_DIR" &&
                mkfifo "$BUILD_DIR/pipe" &&
                (tee "$BUILD_DIR/install.log.txt" < "$BUILD_DIR/pipe" &) &&
                __install_the_given_package_one_build "$1" > "$BUILD_DIR/pipe" 2>&1
            ) || return 1
        fi
    done
}

__install_the_given_package_one_build() {
    step "build for target ${COLOR_GREEN}${TARGET_OS_ABI}${COLOR_OFF}"
    __config_this_build_variables "$1"
    __printf_this_build_variables "$1"

    if [ "$PACKAGE_BUILD_IN_SOURCE_DIR" = YES ] ; then
        if [ "$PWD" != "$SOURCE_DIR" ] ; then
            run cd "$SOURCE_DIR" || return 1
        fi
    else
        run install -d "$BUILD_DIR" || return 1
        run cd "$BUILD_DIR" || return 1
    fi

    if command -v build > /dev/null ; then
        build || return 1
    else
        {
            case $PACKAGE_BUILD_SYSTEM in
                autogen)   configure ;;
                autotools) configure ;;
                configure) configure ;;
                cmake*)    cmakew ;;
                meson)     mesonw ;;
                ninja)     ninja clean && ninja && ninja install ;;
                make)      makew clean && makew && makew install ;;
                cargo)     cargow install ;;
                go)        run go build -v -trimpath ;;
            esac
        } || return 1
    fi
    
    [ -d "$ABI_INSTALL_DIR" ] || {
        error "installed nothing."
        return 1
    }

    run __justfy_la_files || return 1

    run __justfy_pc_files || return 1

    run __install_logs || return 1
}

__justfy_la_files() {
    if [ -d "$ABI_LIBRARY_DIR" ] ; then
        for item in $(find "$ABI_LIBRARY_DIR" -name "*.la")
        do
            sed_in_place "s|-L$SYSTEM_LIBRARY_DIR||" "$item" || return 1
        done
    fi
}

__justfy_pc_files() {
    if [ -d "$ABI_PKGCONF_DIR" ] ; then
        for item in $(find "$ABI_PKGCONF_DIR" -name "*.pc")
        do
            sed_in_place 's/-lpthread//g' "$item" || return 1
            if grep 'Libs.private:' "$item" > /dev/null ; then
                LIBS_CONTENT=$(awk '/Libs:/{print}' "$item" || return 1)
                LIBS_PRIVATE_CONTENT=$(awk -F: '/Libs.private:/{print $2}' "$item" || return 1)
                sed_in_place "s|$LIBS_CONTENT|$LIBS_CONTENT$LIBS_PRIVATE_CONTENT|" "$item" || return 1
                sed_in_place '/Libs.private/d' "$item" || return 1
            fi
        done
    fi
}

__install_logs() {
    ABI_LOG_DIR="$ABI_INSTALL_DIR/share/log"

    run install -d "$ABI_LOG_DIR"

    for item in "$BUILD_DIR" "$SOURCE_DIR"
    do
        for item2 in 'config.log' 'compile_commands.json' 'install.log.txt'
        do
            if [ -f "$item/$item2" ] ; then
                echo "-- Installing: $ABI_LOG_DIR/$item2"
                install -m 644 "$item/$item2" "$ABI_LOG_DIR" || return 1
            fi
        done
    done
}

install_incs() {
    while [ -n "$1" ]
    do
        unset X1
        unset X2
        X1=$(echo "$1" | cut -d: -f1)
        X2=$(echo "$1" | cut -d: -f2)

        if [ "$X1" = "$X2" ] ; then
            unset X2
        fi

        install -v -d         "$ABI_INCLUDE_DIR/$X2" || return 1
        install -v -m 644 $X1 "$ABI_INCLUDE_DIR/$X2" || return 1

        shift
    done
}

install_libs() {
    install -v -d "$ABI_LIBRARY_DIR" || return 1
    for item in $@
    do
        case $item in
            *.a) install -v -m 644 $item "$ABI_LIBRARY_DIR" || return 1 ;;
            *)   install -v -m 755 $item "$ABI_LIBRARY_DIR" || return 1 ;;
        esac
    done
}

install_pcfs() {
    install -v -d        "$ABI_PKGCONF_DIR" &&
    install -v -m 644 $@ "$ABI_PKGCONF_DIR"
}

install_bins() {
    install -v -d        "$ABI_BINARY__DIR" &&
    install -v -m 755 $@ "$ABI_BINARY__DIR"
}

install_mans() {
    for item in $@
    do
        unset NUMBER
        NUMBER=$(echo "$item" | cut -c ${#item}-${#item})
        case $NUMBER in
            [1-8]);;
            *)    die "$item: not a manpage."
        esac
        install -v -d           "$ABI_INSTALL_DIR/share/man/man$NUMBER" &&
        install -v -m 644 $item "$ABI_INSTALL_DIR/share/man/man$NUMBER"
    done
}

install_pc_file() {
    install -v -d "$ABI_PKGCONF_DIR" &&
    cat >         "$ABI_PKGCONF_DIR/$1.pc"
}

__show_infomation_of_all_available_packages() {
    shift

    unset OUTPUT_FORMAT

    while [ -n "$1" ]
    do
        case $1 in
            --json) OUTPUT_FORMAT=json ;;
            *)      die "unrecognized argument: $1"
        esac
        shift
    done

    unset I
    unset PACKAGE_LIST
    unset PACKAGE_LIST_LENGTH

    PACKAGE_LIST=$(__list_available_packages) || return 1
    PACKAGE_LIST_LENGTH=$(list_length $PACKAGE_LIST)

    if [ "$OUTPUT_FORMAT" = 'json' ] ; then
        for PACKAGE in $PACKAGE_LIST
        do
            __load_formula_of_the_given_package "$PACKAGE"

            I=$(expr ${I-0} + 1)

            if [ "$I" -eq 1 ] ; then
                echo "["
            fi

            if [ "$I" -eq "$PACKAGE_LIST_LENGTH" ] ; then
                printf "{\"name\":\"%s\",\"version\":\"%s\",\"summary\":\"%s\",\"license\":\"%s\",\"webpage\":\"%s\",\"bsystem\":\"%s\",\"src_git\":\"%s\"}]\n"  "$PACKAGE_NAME" "$PACKAGE_VERSION" "$PACKAGE_SUMMARY" "$PACKAGE_LICENSE" "$PACKAGE_WEBPAGE" "$PACKAGE_BUILD_SYSTEM" "$PACKAGE_SRC_GIT"
            else
                printf "{\"name\":\"%s\",\"version\":\"%s\",\"summary\":\"%s\",\"license\":\"%s\",\"webpage\":\"%s\",\"bsystem\":\"%s\",\"src_git\":\"%s\"},\n"  "$PACKAGE_NAME" "$PACKAGE_VERSION" "$PACKAGE_SUMMARY" "$PACKAGE_LICENSE" "$PACKAGE_WEBPAGE" "$PACKAGE_BUILD_SYSTEM" "$PACKAGE_SRC_GIT"
            fi
        done
    else
        for PACKAGE in $PACKAGE_LIST
        do
            I=$(expr ${I-0} + 1)

            if [ "$I" -gt 1 ] ; then
                echo "============================================================"
            fi

            __show_infomation_of_the_given_package "$PACKAGE"
        done
    fi
}

# examples:
# __show_infomation_of_the_given_package curl
# __show_infomation_of_the_given_package curl --json
# __show_infomation_of_the_given_package curl version
# __show_infomation_of_the_given_package curl webpage
__show_infomation_of_the_given_package() {
    set -e

    if [ $# -eq 0 ] ; then
        die_if_package_is_not_specified
    fi

    if [ $# -gt 2 ] ; then
        die "too many arguments."
    fi

    if [ $# -eq 2 ] ; then
        case $2 in
            --json)
                __load_formula_of_the_given_package "$1"
                printf "{\"name\":\"%s\",\"version\":\"%s\",\"summary\":\"%s\",\"license\":\"%s\",\"webpage\":\"%s\",\"bsystem\":\"%s\",\"src_git\":\"%s\"}\n"  "$PACKAGE_NAME" "$PACKAGE_VERSION" "$PACKAGE_SUMMARY" "$PACKAGE_LICENSE" "$PACKAGE_WEBPAGE" "$PACKAGE_BUILD_SYSTEM" "$PACKAGE_SRC_GIT"
                ;;
            installed-dir)
                die_if_package_is_not_installed "$1"
                echo "$MY_INSTALL_DIR/$1"
                ;;
            installed-abis)
                die_if_package_is_not_installed "$1"
                cat "$MY_INSTALL_DIR/$1/installed-abis"
                ;;
            installed-metadata)
                die_if_package_is_not_installed "$1"
                cat "$MY_INSTALL_DIR/$1/installed-metadata"
                ;;
            installed-files)
                die_if_package_is_not_installed "$1"
                cat "$MY_INSTALL_DIR/$1/installed-files"
                ;;
            installed-datetime-unix)
                __load_installed_metadata_of_the_given_package "$1"
                echo "$INSTALLED_DATETIME"
                ;;
            installed-datetime-formatted)
                __load_installed_metadata_of_the_given_package "$1"
                format_unix_timestamp "$INSTALLED_DATETIME" '+%Y/%m/%d %H:%M:%S'
                ;;
            installed-pkg-version)
                __load_installed_metadata_of_the_given_package "$1"
                echo "$INSTALLED_PKG_VERS"
                ;;
            *)  package get "$1" "$2"
        esac
        return $?
    fi

    __load_formula_of_the_given_package "$1"

    echo "name    : $(mark_is_package_installed_or_not $1)"

    if [ -n "$PACKAGE_VERSION" ] ; then
        echo "version : $PACKAGE_VERSION"
    fi

    echo "summary : $PACKAGE_SUMMARY"
    echo "webpage : $PACKAGE_WEBPAGE"

    [ -z "$PACKAGE_DEP_PKG" ] || {
        unset DEPENDENCIES

        for dependencyPkgName in $PACKAGE_DEP_PKG
        do
            if [ -z "$DEPENDENCIES" ] ; then
                DEPENDENCIES="depends : $(mark_is_package_installed_or_not $dependencyPkgName)"
            else
                DEPENDENCIES="$DEPENDENCIES | $(mark_is_package_installed_or_not $dependencyPkgName)"
            fi
        done

        echo "$DEPENDENCIES"
    }

    echo "src_url : $PACKAGE_SRC_URL"

    case $PACKAGE_SRC_TYPE in
        dir) ;;
        git)
            if [ -d "$PACKAGE_SRC_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $PACKAGE_SRC_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
            ;;
        *)
            if [ -f "$PACKAGE_SRC_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $PACKAGE_SRC_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
    esac

    is_package_installed "$1" || return 0

    __load_installed_metadata_of_the_given_package "$1"

    echo "installed ${COLOR_PURPLE}==>${COLOR_OFF} $(du -sh "$MY_INSTALL_DIR/$1" | awk '{print $2, $1}')"

    unset I
    unset ABI
    unset INSTALLED_ABIS
    unset INSTALLED_ABIS_LENGTH

    INSTALLED_ABIS=$(cat "$MY_INSTALL_DIR/$1/installed-abis")
    INSTALLED_ABIS_LENGTH=$(list_length $INSTALLED_ABIS)

    MAX=0
    for ABI in $INSTALLED_ABIS
    do
        unset V
        V=$(printf '%s\n' "$ABI" | wc -m)
        if [ "$V" -gt "$MAX" ] ; then
            MAX=$V
        fi
    done

    for ABI in $INSTALLED_ABIS
    do
        I=$(expr ${I-0} + 1)
        if [ "$I" -eq "$INSTALLED_ABIS_LENGTH" ] ; then
            printf "              â””â”€â”€ %-${MAX}s %s\n" "$ABI" "$(du -sh "$MY_INSTALL_DIR/$1/$ABI" | cut -f1)"
        else
            printf "              â”œâ”€â”€ %-${MAX}s %s\n" "$ABI" "$(du -sh "$MY_INSTALL_DIR/$1/$ABI" | cut -f1)"
        fi
    done

    echo "installed datetime    : $(format_unix_timestamp $INSTALLED_DATETIME '+%Y/%m/%d %H:%M:%S')"
    echo "installed pkg version : $INSTALLED_PKG_VERS"
    echo "build with toolchain  : $BUILD_WITH_TOOLCHAIN_NAME $BUILD_WITH_TOOLCHAIN_VERS"
    echo "build with api-level  : $BUILD_WITH_API_LEVEL"
}

mark_is_package_installed_or_not() {
    if is_package_installed "$1" ; then
        echo "${COLOR_GREEN}$1${COLOR_OFF}"
    else
        echo "${COLOR_RED}$1${COLOR_OFF}"
    fi
}

__record_installed_files_of_the_given_package() {
    if [ -z "$2" ] ; then
        INSTALLED_FILES_FILEPATH="$MY_INSTALL_DIR/$1/installed-files"
        echo "-- Installing: $INSTALLED_FILES_FILEPATH"

        exec 7> "$INSTALLED_FILES_FILEPATH"

        __record_installed_files_of_the_given_package "$1" "$MY_INSTALL_DIR/$1"

        exec 7>&-

        sed_in_place "s|$MY_INSTALL_DIR/$1/||" "$INSTALLED_FILES_FILEPATH"
    else
        for file in $(ls $2)
        do
            file="$2/$file"
            if [ -d "$file" ] ; then
                __record_installed_files_of_the_given_package "$1" "$file"
            else
                printf '%s %s\n' $(md5sum "$file") "$file" >&7
            fi
        done
    fi
}

__record_installed_metadata_of_the_given_package() {
    die_if_package_is_not_specified "$1"

    INSTALLED_METADATA_FILEPATH="$MY_INSTALL_DIR/$1/installed-metadata"

    echo "-- Installing: $INSTALLED_METADATA_FILEPATH"

    cat > "$INSTALLED_METADATA_FILEPATH" <<EOF
INSTALLED_DATETIME='$TIMESTAMP_UNIX'

INSTALLED_PKG_NAME='$PACKAGE_NAME'
INSTALLED_PKG_VERS='$PACKAGE_VERSION'

BUILD_WITH_TOOLCHAIN_NAME='$TOOLCHAIN_NAME'
BUILD_WITH_TOOLCHAIN_VERS='$TOOLCHAIN_VERSION'

BUILD_WITH_API_LEVEL='$TARGET_OS_VERS'
EOF
}

__load_installed_metadata_of_the_given_package() {
    die_if_package_is_not_installed "$1"

    unset INSTALLED_DATETIME
    unset INSTALLED_PKG_NAME
    unset INSTALLED_PKG_VERS

    unset BUILD_WITH_TOOLCHAIN_NAME
    unset BUILD_WITH_TOOLCHAIN_VERS

    unset BUILD_WITH_API_LEVEL

    INSTALLED_METADATA_FILEPATH="$MY_INSTALL_DIR/$1/installed-metadata"

    . "$INSTALLED_METADATA_FILEPATH" || die "$INSTALLED_METADATA_FILEPATH is broken."
}

__config_this_build_variables() {
    TARGET_OS_KIND=linux
    TARGET_OS_TYPE=android
    TARGET_OS_NAME=Android
    TARGET_OS_ARCH=$(print_target_arch_by_abi "$TARGET_OS_ABI")


    TARGET_TRIPLE=$(print_target_triple_by_arch "$TARGET_OS_ARCH")

    TARGET_TRIPLE2=$(echo $TARGET_TRIPLE | sed 's/armv7a/arm/')





    for tool in $(list_tools_in_the_toolchain)
    do
        if [ "$tool" = 'cpp' ] ; then
            CPP="$CC -E"
        else
            eval $(echo "$tool" | tr a-z A-Z)=$(path_of_tool_in_the_toolchain "$tool")
        fi
    done

    SYSTEM_INCLUDE_DIR="$SYSROOT/usr/include"
    SYSTEM_LIBRARY_DIR="$SYSROOT/usr/lib/$TARGET_TRIPLE2/$TARGET_OS_VERS"

      CFLAGS="--sysroot $SYSROOT -Qunused-arguments -Os -fpic"
    CPPFLAGS="--sysroot $SYSROOT -Qunused-arguments -I$SYSTEM_INCLUDE_DIR/$TARGET_TRIPLE2"
     LDFLAGS="--sysroot $SYSROOT -L$SYSTEM_LIBRARY_DIR"

    for item in $PACKAGE_CDEFINE
    do
        CPPFLAGS="$CPPFLAGS -D$item"
    done

    CPPFLAGS="$CPPFLAGS -include $COMMON_INCLUDE_H_FILEPATH"

    if [ -n "$PACKAGE_CCFLAGS" ] ; then
        CFLAGS="$CFLAGS $PACKAGE_CCFLAGS"
    fi

    if [ -n "$PACKAGE_LDFLAGS" ] ; then
        LDFLAGS="$LDFLAGS $PACKAGE_LDFLAGS"
    fi

    # https://www.freedesktop.org/wiki/Software/pkg-config/CrossCompileProposal
    unset PKG_CONFIG_LIBDIR
    unset PKG_CONFIG_PATH

    # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
    unset CMAKE_FIND_ROOT_PATH
    unset CMAKE_PREFIX_PATH
    unset CMAKE_INCLUDE_PATH
    unset CMAKE_LIBRARY_PATH

    for PACKAGE in $DEPENDENCY_PACKAGE_LIST
    do
        PKG=$(printf "$PACKAGE" | tr '-' '_')
        
        ABI_INSTALL_DIR="$MY_INSTALL_DIR/$PACKAGE/$TARGET_OS_ABI"
        ABI_INCLUDE_DIR="$ABI_INSTALL_DIR/include"
        ABI_LIBRARY_DIR="$ABI_INSTALL_DIR/lib"
        ABI_PKGCONF_DIR="$ABI_INSTALL_DIR/lib/pkgconfig"

        eval "${PKG}_INSTALL_DIR='$ABI_INSTALL_DIR'"
        eval "${PKG}_INCLUDE_DIR='$ABI_INCLUDE_DIR'"
        eval "${PKG}_LIBRARY_DIR='$ABI_LIBRARY_DIR'"

        CPPFLAGS="-I$ABI_INCLUDE_DIR $CPPFLAGS"
         LDFLAGS="-L$ABI_LIBRARY_DIR $LDFLAGS"

        if [ -z "$PKG_CONFIG_PATH" ] ; then
            PKG_CONFIG_PATH="$ABI_PKGCONF_DIR"
        else
            PKG_CONFIG_PATH="$PKG_CONFIG_PATH:$ABI_PKGCONF_DIR"
        fi

        if [ -z "$CMAKE_FIND_ROOT_PATH" ] ; then
            CMAKE_FIND_ROOT_PATH="$MY_INSTALL_DIR/$PACKAGE"
        else
            CMAKE_FIND_ROOT_PATH="$CMAKE_FIND_ROOT_PATH;$MY_INSTALL_DIR/$PACKAGE"
        fi

        # if [ -z "$CMAKE_INCLUDE_PATH" ] ; then
        #     CMAKE_INCLUDE_PATH="$ABI_LIBRARY_DIR"
        # else
        #     CMAKE_INCLUDE_PATH="$CMAKE_INCLUDE_PATH:$ABI_INCLUDE_DIR"
        # fi

        # if [ -z "$CMAKE_LIBRARY_PATH" ] ; then
        #     CMAKE_LIBRARY_PATH="$ABI_LIBRARY_DIR"
        # else
        #     CMAKE_LIBRARY_PATH="$CMAKE_LIBRARY_PATH:$ABI_LIBRARY_DIR"
        # fi

        if [ -d "$ABI_LIBRARY_DIR/cmake" ] ; then
            for cmake_config_dir in $(find "$ABI_LIBRARY_DIR/cmake" -maxdepth 0 -type d)
            do
                if [ -z "$CMAKE_PREFIX_PATH" ] ; then
                    CMAKE_PREFIX_PATH="$cmake_config_dir"
                else
                    CMAKE_PREFIX_PATH="$CMAKE_PREFIX_PATH;$cmake_config_dir"
                fi
            done
            unset cmake_config_dir
        fi
    done

    # export CMAKE_INCLUDE_PATH="$CMAKE_INCLUDE_PATH"
    # export CMAKE_LIBRARY_PATH="$CMAKE_LIBRARY_PATH"

    if [ "$VERBOSE" = YES ] ; then
        CFLAGS="$CFLAGS -v"
    fi

    CXXFLAGS="$CFLAGS"

    if [ -n "$PACKAGE_XXFLAGS" ] ; then
        CXXFLAGS="$CXXFLAGS $PACKAGE_XXFLAGS"
    fi

    ABI_INSTALL_DIR="$PKG_INSTALL_DIR/$TARGET_OS_ABI"
    ABI_BINARY__DIR="$ABI_INSTALL_DIR/bin"
    ABI_INCLUDE_DIR="$ABI_INSTALL_DIR/include"
    ABI_LIBRARY_DIR="$ABI_INSTALL_DIR/lib"
    ABI_PKGCONF_DIR="$ABI_INSTALL_DIR/lib/pkgconfig"

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            cargo)
                for supportedTarget in $(__list_supported_target_triples)
                do
                    supportedTarget=$(echo "$supportedTarget" | sed 's/armv7a/armv7/')
                    for installedTarget in $(rustup target list | grep installed | cut -d " " -f1)
                    do
                        if [ "$supportedTarget" = "$installedTarget" ] ; then
                            break
                        fi
                    done
                    [ "$supportedTarget" = "$installedTarget" ] || {
                        rustup target add "$supportedTarget" || return 1
                    }
                done

                CARGO_TARGET=$(echo "$TARGET_TRIPLE" | sed 's/armv7a/armv7/')

                # https://doc.rust-lang.org/cargo/reference/environment-variables.html
                CARGO_TARGET_XXX=$(echo "$CARGO_TARGET" | tr a-z A-Z | tr - _)

                eval export "CARGO_TARGET_${CARGO_TARGET_XXX}_AR=\"$AR\""
                eval export "CARGO_TARGET_${CARGO_TARGET_XXX}_LINKER=\"$CC\""

                # https://libraries.io/cargo/cc
                export HOST_CC="$CC_FOR_BUILD"
                export HOST_CFLAGS="$CFLAGS_FOR_BUILD"

                export HOST_CXX="$CXX_FOR_BUILD"
                export HOST_CXXFLAGS="$CXXFLAGS_FOR_BUILD"

                export HOST_AR="$AR_FOR_BUILD"

                export TARGET_CC="$CC"
                export TARGET_CFLAGS="$CFLAGS $CPPFLAGS $LDFLAGS"

                export TARGET_CXX="$CXX"
                export TARGET_CXXFLAGS="$CXXFLAGS $CPPFLAGS $LDFLAGS"

                export TARGET_AR="$AR"

                for item in $DEPENDENCY_PACKAGE_LIST
                do
                    case $item in
                        openssl)
                            unset OPENSSL_DIR
                            # https://docs.rs/openssl/0.10.35/openssl/
                            export OPENSSL_DIR="$openssl_INSTALL_DIR"
                            ;;
                    esac
                done
                ;;
               go)
                # https://golang.org/doc/install/source#environment
                export CGO_ENABLED=1
                export CGO_CFLAGS="$CFLAGS"
                export CGO_CXXFLAGS="$CXXFLAGS"
                export CGO_CPPFLAGS="$CPPFLAGS"
                export CGO_LDFLAGS="$LDFLAGS"

                export GO111MODULE="auto"
                export GOPROXY=https://goproxy.cn

                export GOOS="$TARGET_OS_TYPE"

                case $TARGET_OS_ARCH in
                    armv7a)  export GOARCH=arm   ;;
                    aarch64) export GOARCH=arm64 ;;
                    i686)    export GOARCH=386   ;;
                    x86_64)  export GOARCH=amd64 ;;
                esac
                ;;
        esac
    done
}

__printf_this_build_variables() {
    echo
    echo " BUILD_ROUND_NUM  = $BUILD_ROUND_NUM"
    echo
    echo " NATIVE_OS_KIND   = $NATIVE_OS_KIND"
    echo " NATIVE_OS_TYPE   = $NATIVE_OS_TYPE"
    echo " NATIVE_OS_NAME   = $NATIVE_OS_NAME"
    echo " NATIVE_OS_VERS   = $NATIVE_OS_VERS"
    echo " NATIVE_OS_ARCH   = $NATIVE_OS_ARCH"
    echo " NATIVE_OS_LIBC   = $NATIVE_OS_LIBC"
    echo " NATIVE_OS_SUBS   = $NATIVE_OS_SUBS"
    echo
    echo " TARGET_OS_KIND   = $TARGET_OS_KIND"
    echo " TARGET_OS_TYPE   = $TARGET_OS_TYPE"
    echo " TARGET_OS_NAME   = $TARGET_OS_NAME"
    echo " TARGET_OS_VERS   = $TARGET_OS_VERS"
    echo " TARGET_OS_ARCH   = $TARGET_OS_ARCH"
    echo
    echo " TARGET_OS_ABI    = $TARGET_OS_ABI"
    echo " TARGET_TRIPLE    = $TARGET_TRIPLE"
    echo
    echo "TOOLCHAIN_NAME    = $TOOLCHAIN_NAME"
    echo "TOOLCHAIN_VERSION = $TOOLCHAIN_VERSION"
    echo "ANDROID_NDK_HOME  = $ANDROID_NDK_HOME"
    echo "TOOLCHAIN_BIN_DIR = $TOOLCHAIN_BIN_DIR"
    echo "          SYSROOT = $SYSROOT"
    echo "SYSTEM_INCLUDE_DIR= $SYSTEM_INCLUDE_DIR"
    echo "SYSTEM_LIBRARY_DIR= $SYSTEM_LIBRARY_DIR"
    echo

    for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
    do
        eval export "$TOOL=\"\$$TOOL\""
        printf "%17s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
    done

    echo

    for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
    do
        eval export "${TOOL}_FOR_BUILD=\"\$${TOOL}_FOR_BUILD\""
        printf "%17s = %s\n" "${TOOL}_FOR_BUILD" "$(eval echo \$${TOOL}_FOR_BUILD)"
    done

    echo

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        eval export "$FLAG=\"\$$FLAG\""
        printf "\n%17s = " "$FLAG"
        FIRST=YES
        for item in $(eval echo \$$FLAG | tr ':' ' ')
        do
            if [ "$FIRST" = YES ] ; then
                FIRST=NO
                echo "$item"
            else
                echo "                    $item"
            fi
        done
    done

    echo

    printf "\n%17s = " PATH
    FIRST=YES
    for item in $(echo "$PATH" | tr ':' ' ')
    do
        if [ "$FIRST" = YES ] ; then
            FIRST=NO
            echo "$item"
        else
            echo "                    $item"
        fi
    done

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            cargo)
                echo
                env | grep CARGO
                echo
                echo "    HOST_AR       = $HOST_AR"
                echo "    HOST_CC       = $HOST_CC"
                echo "    HOST_CXX      = $HOST_CXX"
                echo "    HOST_CFLAGS   = $HOST_CFLAGS"
                echo "    HOST_CXXFLAGS = $HOST_CXXFLAGS"
                echo
                echo "  TARGET_AR       = $TARGET_AR"
                echo "  TARGET_CC       = $TARGET_CC"
                echo "  TARGET_CXX      = $TARGET_CXX"
                echo "  TARGET_CFLAGS   = $TARGET_CFLAGS"
                echo "  TARGET_CXXFLAGS = $TARGET_CXXFLAGS"
                ;;
               go)
                echo
                echo "      GOOS        = $GOOS"
                echo "      GOARCH      = $GOARCH"
                echo
                echo "      GO111MODULE = $GO111MODULE"
                echo "      GOPROXY     = $GOPROXY"
                echo
                echo "     CGO_ENABLED  = $CGO_ENABLED"
                echo "     CGO_CFLAGS   = $CGO_CFLAGS"
                echo "     CGO_CXXFLAGS = $CGO_CXXFLAGS"
                echo "     CGO_CPPFLAGS = $CGO_CPPFLAGS"
                echo "     CGO_LDFLAGS  = $CGO_LDFLAGS"
                ;;
        esac
    done

    echo
    echo "   TIMESTAMP_UNIX = $TIMESTAMP_UNIX"
    echo
    echo "      WORKING_DIR = $WORKING_DIR"
    echo "       SOURCE_DIR = $SOURCE_DIR"
    echo "        BUILD_DIR = $BUILD_DIR"
    echo "              PWD = $PWD"
    echo
    echo "  PKG_INSTALL_DIR = $PKG_INSTALL_DIR"
    echo "  ABI_INSTALL_DIR = $ABI_INSTALL_DIR"
    echo "  ABI_BINARY__DIR = $ABI_BINARY__DIR"
    echo "  ABI_INCLUDE_DIR = $ABI_INCLUDE_DIR"
    echo "  ABI_LIBRARY_DIR = $ABI_LIBRARY_DIR"
    echo "  ABI_PKGCONF_DIR = $ABI_PKGCONF_DIR"
    echo
    echo "            NPROC = $NPROC"
    echo "            NJOBS = $NJOBS"
    echo

    if [ "$VERBOSE" = YES ] ; then
        echo
        run export -p
        echo
    fi
}

cargow() {
    case $1 in
        build)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-build.html
            unset CARGO_BUILD_ARGS
            unset CARGO_BUILD_ARG_TARGET
            unset CARGO_BUILD_ARG_RELEASE
            unset CARGO_BUILD_ARG_VV
            for arg in $@
            do
                case $arg in
                    --target)  CARGO_BUILD_ARG_TARGET=set  ;;
                    --release) CARGO_BUILD_ARG_RELEASE=set ;;
                    --vv)      CARGO_BUILD_ARG_VV=set      ;;
                esac
            done
            CARGO_BUILD_ARGS="$@"
            if [ -z "$CARGO_BUILD_ARG_VV" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS -vv"
            fi
            if [ -z "$CARGO_BUILD_ARG_RELEASE" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --release"
            fi
            if [ -z "$CARGO_BUILD_ARG_TARGET" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --target $CARGO_TARGET"
            fi
            run cargo clean && run cargo $CARGO_BUILD_ARGS
            ;;
        install)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-install.html
            unset CARGO_INSTALL_ARGS
            unset CARGO_INSTALL_ARG_TARGET
            unset CARGO_INSTALL_ARG_PATH
            unset CARGO_INSTALL_ARG_ROOT
            unset CARGO_INSTALL_ARG_VV
            for arg in $@
            do
                case $arg in
                    --target) CARGO_INSTALL_ARG_TARGET=set ;;
                    --path)   CARGO_INSTALL_ARG_PATH=set   ;;
                    --root)   CARGO_INSTALL_ARG_ROOT=set   ;;
                    --vv)     CARGO_INSTALL_ARG_VV=set     ;;
                esac
            done
            CARGO_INSTALL_ARGS="$@"
            if [ -z "$CARGO_INSTALL_ARG_VV" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS -vv"
            fi
            if [ -z "$CARGO_INSTALL_ARG_TARGET" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --target $CARGO_TARGET"
            fi
            if [ -z "$CARGO_INSTALL_ARG_PATH" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --path $SOURCE_DIR"
            fi
            if [ -z "$CARGO_INSTALL_ARG_ROOT" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --root=$ABI_INSTALL_DIR"
            fi
            run cargo clean && run cargo $CARGO_INSTALL_ARGS
            ;;
        *) cargo $@
    esac
}

config_url() {
    echo "http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=$1;hb=HEAD"
}

# run in a subshell
configure() {
    if [ -z "$CONFIG_XX_UPDATED" ] ; then
        CONFIG_XX_UPDATED=YES
        # https://www.gnu.org/software/gettext/manual/html_node/config_002eguess.html
        # https://git.savannah.gnu.org/cgit/config.git/tree/
        for item in config.sub config.guess
        do
            for file in $(find "$SOURCE_DIR" -name "$item")
            do
                CONFIG_XX="$MY_SOURCE_DIR/config/$item"
                if [ ! -f "$CONFIG_XX" ] ; then
                    fetch "$(config_url "$item")" --output-path="$CONFIG_XX" || return 1
                    run chmod a+x "$CONFIG_XX" || return 1
                    if [ "$item" = 'config.sub' ] ; then
                        sed_in_place 's/arm64-*/arm64-*|arm64e-*/g' "$CONFIG_XX" || return 1
                    fi
                fi
                run cp -f "$CONFIG_XX" "$file" || return 1
            done
        done
    fi

    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        if run "$SOURCE_DIR"/configure \
            --prefix="$NATIVE_INSTALL_DIR" \
            $@ ; then
            echo
        else
            if [ -f "$BUILD_DIR/config.log" ] ; then
                run cat "$BUILD_DIR/config.log"
            elif [ -f "$SOURCE_DIR/config.log" ] ; then
                run cat "$SOURCE_DIR/config.log"
            fi
            return 1
        fi
    else
        if run "$SOURCE_DIR"/configure \
            --host="\"$TARGET_TRIPLE\"" \
            --prefix="\"$ABI_INSTALL_DIR\"" \
            --disable-option-checking \
            --disable-rpath \
            --disable-debug \
            --disable-nls\
            --enable-largefile \
            --enable-static \
            --enable-shared \
            CC="\"$CC\"" \
            CFLAGS="\"$CFLAGS\"" \
            CXX="\"$CXX\"" \
            CXXFLAGS="\"$CXXFLAGS\"" \
            CPP="\"$CPP\"" \
            CPPFLAGS="\"$CPPFLAGS\"" \
            LDFLAGS="\"$LDFLAGS\"" \
            AR="\"$AR\"" \
            RANLIB="\"$RANLIB\"" \
            PKG_CONFIG="\"$PKG_CONFIG\"" \
            PKG_CONFIG_PATH="\"$PKG_CONFIG_PATH\"" \
            PKG_CONFIG_LIBDIR="\"\"" \
            CC_FOR_BUILD="\"$CC_FOR_BUILD\"" \
            $@ ; then
            echo
        else
            if [ -f "$BUILD_DIR/config.log" ] ; then
                run cat "$BUILD_DIR/config.log"
            elif [ -f "$SOURCE_DIR/config.log" ] ; then
                run cat "$SOURCE_DIR/config.log"
            fi
            return 1
        fi
    fi

    if [ "$VERBOSE" = YES ] ; then
        for Makefile in $(find "$SOURCE_DIR" -name Makefile)
        do
            sed_in_place 's|\t@|\t|g'     "$Makefile" || return 1
            sed_in_place 's|@echo|echo|g' "$Makefile" || return 1
        done
        unset Makefile
    fi

    makew clean &&
    makew       &&
    makew install
}

# make wrapper
makew() {
    if [ "$DEBUG" = YES ] ; then
        run "$GMAKE -w -j$NJOBS --debug V=1 $*"
    else
        run "$GMAKE -w -j$NJOBS $*"
    fi
}

# https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling
# https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html
# https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
# https://cmake.org/cmake/help/latest/command/enable_testing.html?highlight=build_testing
# run in a subshell
cmakew() {
    CMAKE_FLAGS="
        -Wno-dev
        -G 'Unix Makefiles'
        -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
        -DCMAKE_VERBOSE_MAKEFILE=ON
        -DCMAKE_COLOR_MAKEFILE=ON
        -DCMAKE_BUILD_TYPE=Release
        -DBUILD_TESTING=OFF"

    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        CMAKE_FLAGS="
            $CMAKE_FLAGS
            -DBUILD_SHARED_LIBS=OFF
            -DCMAKE_INSTALL_PREFIX='$NATIVE_INSTALL_DIR'"

        # https://stackoverflow.com/questions/11143062/getting-cmake-to-build-out-of-source-without-wrapping-scripts
        if command_exists_in_filesystem_and_version_matched cmake ge 3.13.0 ; then
            CMAKE_FLAGS="$CMAKE_FLAGS -S $SOURCE_DIR -B $NATIVE_BUILD_DIR"
        else
            CMAKE_FLAGS="$CMAKE_FLAGS -H$SOURCE_DIR -B$NATIVE_BUILD_DIR"
        fi

        run $CMAKE $CMAKE_FLAGS $@ &&
        makew -C "$NATIVE_BUILD_DIR" &&
        makew -C "$NATIVE_BUILD_DIR" install
    else
        # CMAKE_HOST_SYSTEM_NAME = $(uname -s)
        # CMAKE_HOST_SYSTEM_NAME on msys2 is not Windows
        if [ "$NATIVE_OS_KIND" = 'windows' ] ; then
            sed_in_place 's|elseif(CMAKE_HOST_SYSTEM_NAME STREQUAL Windows)|else()|g' "$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake"
        fi

        CMAKE_FLAGS="
        $CMAKE_FLAGS
        -DCMAKE_TOOLCHAIN_FILE='$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake'
        -DCMAKE_INSTALL_PREFIX='$ABI_INSTALL_DIR'
        -DCMAKE_PREFIX_PATH='$CMAKE_PREFIX_PATH'
        -DCMAKE_FIND_ROOT_PATH='$CMAKE_FIND_ROOT_PATH'
        -DCMAKE_C_FLAGS='$CFLAGS $CPPFLAGS $LDFLAGS'
        -DCMAKE_CXX_FLAGS='$CFLAGS $CPPFLAGS $LDFLAGS'
        -DBUILD_SHARED_LIBS=ON 
        -DANDROID_TOOLCHAIN=clang
        -DANDROID_ABI=$TARGET_OS_ABI
        -DANDROID_ARM_NEON=TRUE
        -DANDROID_PLATFORM=$TARGET_OS_VERS"

        # https://stackoverflow.com/questions/11143062/getting-cmake-to-build-out-of-source-without-wrapping-scripts
        if command_exists_in_filesystem_and_version_matched cmake ge 3.13.0 ; then
            CMAKE_FLAGS="$CMAKE_FLAGS -S $SOURCE_DIR -B $BUILD_DIR"
        else
            CMAKE_FLAGS="$CMAKE_FLAGS -H$SOURCE_DIR -B$BUILD_DIR"
        fi

        run $CMAKE $CMAKE_FLAGS $@ &&
        makew -C "$BUILD_DIR" &&
        makew -C "$BUILD_DIR" install
    fi
}

# https://mesonbuild.com/Cross-compilation.html
# run in a subshell
mesonw() {
    case $TARGET_OS_ARCH in
        armv7a)
            HOST_MACHINE_CPU_FAMILY='arm'
            HOST_MACHINE_CPU_NAME="$TARGET_OS_ARCH"
            ;;
        aarch64)
            HOST_MACHINE_CPU_FAMILY='aarch64'
            HOST_MACHINE_CPU_NAME='armv8a'
            ;;
        i686)
            HOST_MACHINE_CPU_FAMILY='x86'
            HOST_MACHINE_CPU_NAME="$TARGET_OS_ARCH"
            ;;
        x86_64)
            HOST_MACHINE_CPU_FAMILY='x86_64'
            HOST_MACHINE_CPU_NAME="$TARGET_OS_ARCH"
            ;;
    esac

    cat >> "$BUILD_DIR/cross-file" <<EOF
[host_machine]
system = '$TARGET_OS_TYPE'
endian = 'little'
cpu_family = '$HOST_MACHINE_CPU_FAMILY'
cpu = '$HOST_MACHINE_CPU_NAME'

[binaries]
c = '$CC'
cpp = '$CXX'
ar = '$AR'
strip = '$STRIP'
cmake = '$CMAKE'
pkgconfig = '$PKG_CONFIG'

[properties]
c_args = $(to_meson_array $CFLAGS $CPPFLAGS)
c_link_args = $(to_meson_array $LDFLAGS)
cpp_args = $(to_meson_array $CXXFLAGS $CPPFLAGS)
cpp_link_args = $(to_meson_array $LDFLAGS)
EOF
    run "$MESON" setup \
        --prefix="$ABI_INSTALL_DIR" \
        --buildtype=release \
        --backend=ninja \
        --pkg-config-path="$PKG_CONFIG_PATH" \
        --build.pkg-config-path="$PKG_CONFIG_PATH_FOR_BUILD" \
        --cross-file="$BUILD_DIR/cross-file" \
        -Ddefault_library=static \
        $@ "$BUILD_DIR" "$SOURCE_DIR" &&
    {
        if command -v build_configed > /dev/null ; then
            build_configed
        fi
    } &&
    run ninja -C "$BUILD_DIR" &&
    run ninja -C "$BUILD_DIR" install
}

to_meson_array() {
    RESULT="[''"
    for item in $@
    do
        RESULT="$RESULT, '$item'"
    done
    RESULT="$RESULT]"
    echo "$RESULT"
}


########################################################################

include_stub_getdtablesize() {
    # https://linux.die.net/man/2/getdtablesize
    # https://hg.mozilla.org/mozreview/gecko/rev/038c2fe02074d03a6c34d44f68cb5f078a2472cc#index_header
    if [ "$BUILD_ROUND_NUM" -eq 1 ] ; then
        cat > "$SOURCE_DIR/stub-getdtablesize.c" <<EOF
#ifndef STUB_GETDTABLESIZE_H
#define STUB_GETDTABLESIZE_H

/* sysinfo is defined but not implemented.
 * we may be able to implement it ourselves. */
#define _SYS_SYSINFO_H_

#include <sys/cdefs.h>
#include <sys/resource.h>
#include <linux/kernel.h>
#include <unistd.h>

/* Use this stub version of getdtablesize
 * instead of the one in the header */
__attribute__((unused))
static int stub_getdtablesize(void) {
    struct rlimit r;
    if (getrlimit(RLIMIT_NOFILE, &r) < 0) {
        return sysconf(_SC_OPEN_MAX);
    }
    return r.rlim_cur;
}

#define getdtablesize() stub_getdtablesize()

#if __ANDROID_API__ < 21
#define RTLD_NOLOAD 0
#endif

#define sysinfo(foo) -1

#endif
EOF
    fi
    export CPPFLAGS="$CPPFLAGS -include $SOURCE_DIR/stub-getdtablesize.c"
}

list_all_installed_libs() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
        cd  "$MY_INSTALL_DIR" || return 1
    else
        return 0
    fi

    for item in *
    do
        if is_package_installed "$item" ; then
            if [ -d "$MY_INSTALL_DIR/$item/libs" ] ; then
                find "$MY_INSTALL_DIR/$item/libs" -name "lib*\.a"
            fi
        fi
    done
}

__ldd() {
    inspect_build_toolchains

    die_if_package_is_not_installed "$1"
    die_if_abi_____is_not_supported "$2"

    if [ -z "$3" ] ; then
        die "type is not specified."
    fi

    if [ -z "$4" ] ; then
        die "name is not specified."
    fi

    TARGET_OS_ARCH=$(print_target_arch_by_abi "$2")
    TARGET_TRIPLE=$(print_target_triple_by_arch "$TARGET_OS_ARCH")
    READELF="$(path_of_tool_in_the_toolchain readelf)"
    export PATH="$TOOLCHAIN_BIN_DIR:$PATH"

    ldd_recursion() {
        die_if_package_is_not_installed "$1"
        die_if_abi_____is_not_supported "$2"
        if [ -z "$3" ] ; then
            die "type is not specified."
        fi
        if [ -z "$4" ] ; then
            die "name is not specified."
        fi

        FILE_PATH="$MY_INSTALL_DIR/$1/$2/$3/$4"
        [ -f "$FILE_PATH" ] || die "$FILE_PATH not exist."
        echo "$FILE_PATH"

        DLL=$("$READELF" -d "$FILE_PATH" | grep ".so" | sed 's/.*\[\(.*\)\].*/\1/')
        for item in $DLL
        do
            ldd_recursion $(read_ldd_cache $item) $(expr "$5" + 1)
        done
    }

    ldd_recursion "$1" "$2" "$3" "$4" 0
}

list_dynamic_library_names_of_the_given_package() {
    die_if_package_is_not_specified "$1"
    die_if_package_is_not_installed "$1"

    ABI=$(__list_supported_target_abis | head -n 1)
    ABI_LIBRARY_DIR="$MY_INSTALL_DIR/$1/$ABI/lib"
    if [ -d  "$ABI_LIBRARY_DIR" ] ; then
        find "$ABI_LIBRARY_DIR" -name "*.so*" -a -maxdepth 0 -a \( -type f -o -type l \) -exec basename {} \;
    fi
}

__list_supported_target_sdk_api_levels() {
    if [ -z "$TOOLCHAIN_BIN_DIR" ] ; then
        inspect_build_toolchains > /dev/null
    fi
    ls "$TOOLCHAIN_BIN_DIR" | sed -n '/aarch64-linux-android[1-9][0-9]-clang++/p' | cut -d- -f3 | sed 's/android//'
}

__list_supported_target_archs() {
    list armv7a aarch64 i686 x86_64
}

__list_supported_target_abis() {
    list armeabi-v7a arm64-v8a x86 x86_64
}

__list_supported_target_triples() {
    for ARCH in $(__list_supported_target_archs)
    do
        print_target_triple_by_arch "$ARCH"
    done
}

print_target_arch_by_abi() {
    case $1 in
        '')          die  "abi is not specified." ;;
        armeabi-v7a) echo armv7a  ;;
        arm64-v8a)   echo aarch64 ;;
        x86)         echo i686    ;;
        x86_64)      echo x86_64  ;;
    esac
}

print_target_triple_by_arch() {
    case $1 in
        '')     die   "arch is not specified."   ;;
        armv7a) echo  "armv7a-linux-androideabi" ;;
        *)      echo  "$1-linux-android"         ;;
    esac
}

list_tools_in_the_toolchain() {
    list cc cxx cpp as ld ar ranlib nm size strip strings objdump objcopy readelf
}

list_flags_used_by_tools_in_the_toolchain() {
    list CFLAGS CXXFLAGS CPPFLAGS LDFLAGS PKG_CONFIG_PATH PKG_CONFIG_LIBDIR
}

path_of_tool_in_the_toolchain() {
    unset EXE
    if [ "$NATIVE_OS_KIND" = windows ] ; then
        EXE=.exe
    fi

    unset TOOL_FILENAME
    case $1 in
        cc)  TOOL_FILENAME="$TARGET_TRIPLE$TARGET_OS_VERS-clang"   ;;
        cxx) TOOL_FILENAME="$TARGET_TRIPLE$TARGET_OS_VERS-clang++" ;;
        *)   TOOL_FILENAME="$(echo $TARGET_TRIPLE | sed 's/armv7a/arm/')-$1"
             if [ "$1" = 'ld' ] ; then
                # https://github.com/android/ndk/wiki/Changelog-r22
                if [ ! -e "$TOOLCHAIN_BIN_DIR/$TOOL_FILENAME$EXE" ] ; then
                    TOOL_FILENAME=lld
                fi
             fi

             # https://github.com/android/ndk/wiki/Changelog-r23
             if [ ! -e "$TOOLCHAIN_BIN_DIR/$TOOL_FILENAME$EXE" ] ; then
                 TOOL_FILENAME=llvm-$1
             fi
    esac
    die_if_not_executable "$TOOLCHAIN_BIN_DIR/$TOOL_FILENAME"
    echo "$TOOL_FILENAME"
}

# $1: target_os_version configed in formula
# $2: target_os_version sepecified by user
# return 0: succees
# return 1: $1 > $2
pick_target_os_version() {
    if [ -z "$1" ] ; then
        pick_target_os_version $(__list_supported_target_sdk_api_levels | head -n 1) $2
    else
        if [ -z "$2" ] ; then
            echo "$1"
        else
            if [ "$1" -gt "$2" ] ; then
                return 1
            else
                echo "$2"
            fi
        fi
    fi
}

ndk_version() {
    if   command -v cut  > /dev/null ; then
        grep "Pkg.Revision" "$ANDROID_NDK_HOME/source.properties" | cut -d " " -f3
    elif command -v awk  > /dev/null ; then
        awk -F= '/Pkg.Revision/{print(substr($2, 2))}' "$ANDROID_NDK_HOME/source.properties"
    elif command -v sed  > /dev/null ; then
        grep "Pkg.Revision" "$ANDROID_NDK_HOME/source.properties" | sed  's/Pkg\.Revision = \(.*\).*/\1/'
    elif command -v gsed > /dev/null ; then
        grep "Pkg.Revision" "$ANDROID_NDK_HOME/source.properties" | gsed 's/Pkg\.Revision = \(.*\).*/\1/'
    elif command -v ruby > /dev/null ; then
        ruby <<EOF
File.open(ENV['ANDROID_NDK_HOME'] + '/source.properties', 'r') {|f|
  f.each_line {|lineText|
    if (lineText =~ /Pkg.Revision =.*/)
        puts lineText.gsub('Pkg.Revision = ', '')
    end
  }
  f.close
}
EOF
    elif command -v perl > /dev/null ; then
        perl << EOF
open(DATA, "<$ANDROID_NDK_HOME/source.properties") or die "$ANDROID_NDK_HOME/source.propertiesæ–‡ä»¶æ— æ³•æ‰“å¼€, $!";
while(<DATA>) {
    if ("\$_" =~ m/Pkg.Revision/) {
        print substr("\$_", 15);
    }
}
EOF
    elif command -v node > /dev/null ; then
        node << EOF
const fs = require('fs');

const buffer = fs.readFileSync("$ANDROID_NDK_HOME/source.properties");
if (buffer instanceof Error) {
    console.log(buffer);
    process.exit(1);
}

const text = buffer.toString();
const lines = text.split('\n');
lines.forEach((line, index, lines) => {
    const matched = line.match(/\d+\.\d+\.\d+/);
    if (matched) {
        console.log(matched[0]);
    }
});
EOF
    else
        PYTHON=$(command -v python3) ||
        PYTHON=$(command -v python)  ||
        PYTHON=$(command -v python2)

        if [ -z "$PYTHON" ] ; then
            die "please install GNU CoreUtils."
        else
            "$PYTHON" << EOF
import re;
file = open("$ANDROID_NDK_HOME/source.properties");
lines = file.readlines();
for line in lines:
    if -1 != line.find("Pkg.Revision"):
        print(re.findall("[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,7}", line)[0]);
EOF
        fi
    fi
}

ndk_version_major() {
    if   command -v cut > /dev/null ; then
        printf "$ANDROID_NDK_VERSION" | cut -d. -f1
    elif command -v awk > /dev/null ; then
        printf "$ANDROID_NDK_VERSION" | awk -F. '{print $1}'
    elif command -v sed > /dev/null ; then
        printf "$ANDROID_NDK_VERSION" | sed 's/\..*//g'
    else
        die "please install GNU CoreUtils."
    fi
}

is_a_valid_android_ndk_home_dir() {
    [ -d "$1" ] &&
    [ -f "$1/source.properties" ] &&
    [ -f "$1/build/cmake/android.toolchain.cmake" ] &&
    [ -d "$1/toolchains/llvm/prebuilt/$NATIVE_OS_KIND-$NATIVE_OS_ARCH" ] &&
    [ -d "$1/toolchains/llvm/prebuilt/$NATIVE_OS_KIND-$NATIVE_OS_ARCH/bin" ] &&
    [ -d "$1/toolchains/llvm/prebuilt/$NATIVE_OS_KIND-$NATIVE_OS_ARCH/sysroot" ]
}

get_android_ndk_download_config() {
{
    # https://developer.android.google.cn/ndk/downloads
    cat <<EOF
linux  |x86_64 |e3eacf80016b91d4cd2c8ca9f34eebd32df912bb799c859cc5450b6b19277b4f|https://dl.google.com/android/repository/android-ndk-r23-linux.zip
linux  |aarch64|1a0b22ee995e1667312ada8faef9c5115bdcd93397353d7485b57b0547ca703b|https://github.com/Lzhiyong/termux-ndk/releases/download/android-ndk/android-ndk-r23.tar.xz
darwin |x86_64 |437278103a3db12632c05b1be5c41bbb8522791a67e415cc54411a65366f499d|https://dl.google.com/android/repository/android-ndk-r21e-darwin-x86_64.zip
windows|x86_64 |40325b5bfdb7f6de016ea3efee0468a7d306eda55a6f80966a501645ba01fbfa|https://dl.google.com/android/repository/android-ndk-r23-windows.zip
EOF
} | while read LINE
    do
        LINE=$(printf '%s' "$LINE" | sed 's/[[:space:]]//g')

        unset __XX_OS_KIND__
        unset __XX_OS_ARCH__

        __XX_OS_KIND__=$(printf '%s' "$LINE" | cut -d '|' -f1)

        if [ "$__XX_OS_KIND__" != "$NATIVE_OS_KIND" ] ; then
            continue
        fi

        __XX_OS_ARCH__=$(printf '%s' "$LINE" | cut -d '|' -f2)

        if [ -n "$__XX_OS_ARCH__" ] && [ "$__XX_OS_ARCH__" != "$NATIVE_OS_ARCH" ] ; then
            continue
        fi

        printf '%s' "$LINE"

        break
    done
}

install_android_ndk() {
    set -e

    for arg in $@
    do
        case $arg in
            -x) set -x ; break
        esac
    done

    unset ANDROID_NDK_URL
    unset ANDROID_NDK_SHA256

    unset LINE
    LINE=$(get_android_ndk_download_config)

    ANDROID_NDK_SHA256=$(printf '%s' "$LINE" | cut -d '|' -f3)

    ANDROID_NDK_URL=$(printf '%s' "$LINE" | cut -d '|' -f4)

    fetch "$ANDROID_NDK_URL" --sha256="$ANDROID_NDK_SHA256" --output-dir="$MY_HOME_DIR"

    case $ANDROID_NDK_URL in
        *.zip)
            handle_dependency required exe unzip
            run unzip -q "$FETCH_OUTPUT_PATH" -d "$MY_HOME_DIR"
            ;;
        *.tar.xz)
            handle_dependency required exe tar
            handle_dependency required exe xz
            run tar xf "$FETCH_OUTPUT_PATH" -C "$MY_HOME_DIR"
            ;;
    esac

    unset ANDROID_NDK_VERSION_CODE
    ANDROID_NDK_VERSION_CODE=$(printf '%s' "$FETCH_OUTPUT_NAME" | cut -d- -f3 | cut -d. -f1)

    unset ANDROID_NDK_HOME
    ANDROID_NDK_HOME="$FETCH_OUTPUT_DIR/android-ndk-$ANDROID_NDK_VERSION_CODE"

    run ls -l "$ANDROID_NDK_HOME"

    run "printf 'ANDROID_NDK_HOME=%s\n' '$ANDROID_NDK_HOME' >> '$MY_ENV_FILEPATH'"
    run "printf 'PATH=%s:$PATH\n' '$ANDROID_NDK_HOME' >> '$MY_ENV_FILEPATH'"
}

inspect_build_toolchains() {
    echo

    if [ -n "$ANDROID_NDK_HOME" ] ; then
        if [ "$NATIVE_OS_SUBS" = cygwin ] ; then
            case "$ANDROID_NDK_HOME" in
                [A-Z]:*) ANDROID_NDK_HOME="$(cygpath "$ANDROID_NDK_HOME")"
            esac
        fi
        if is_a_valid_android_ndk_home_dir "$ANDROID_NDK_HOME" ; then
            echo "you have set the ${COLOR_RED}ANDROID_NDK_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_NDK_HOME${COLOR_OFF}, which is used as the android ndk home."
        else
            echo "you have set the ${COLOR_RED}ANDROID_NDK_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_NDK_HOME${COLOR_OFF}, but it is not a valid android ndk home directory."
            unset ANDROID_NDK_HOME
        fi
    fi

    if [ -z "$ANDROID_NDK_HOME" -a -n "$ANDROID_NDK_ROOT" ] ; then
        if is_a_valid_android_ndk_home_dir "$ANDROID_NDK_ROOT" ; then
            echo "you have set the ${COLOR_RED}ANDROID_NDK_ROOT${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_NDK_ROOT${COLOR_OFF}, which is used as the android ndk home."
            export ANDROID_NDK_HOME="$ANDROID_NDK_ROOT"
        else
            echo "you have set the ${COLOR_RED}ANDROID_NDK_ROOT${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_NDK_ROOT${COLOR_OFF}, but it is not a valid android ndk home directory."
        fi
    fi

    # https://developer.android.com/studio/command-line/variables
    if [ -z "$ANDROID_NDK_HOME" -a -n "$ANDROID_HOME" ] ; then
        if is_a_valid_android_ndk_home_dir "$ANDROID_HOME/ndk-bundle" ; then
            echo "you have set the ${COLOR_RED}ANDROID_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_HOME${COLOR_OFF}, ${COLOR_GREEN}$ANDROID_HOME/ndk-bundle${COLOR_OFF}, which is used as the android ndk home."
            export ANDROID_NDK_HOME="$ANDROID_HOME/ndk-bundle"
        else
            echo "you have set the ${COLOR_RED}ANDROID_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_HOME${COLOR_OFF}, ${COLOR_GREEN}$ANDROID_HOME/ndk-bundle${COLOR_OFF} direcotory is not exist."
        fi
    fi

    if [ -z "$ANDROID_NDK_HOME" -a -n "$ANDROID_SDK_ROOT" ] ; then
        if is_a_valid_android_ndk_home_dir "$ANDROID_SDK_ROOT/ndk-bundle" ; then
            echo "you have set the ${COLOR_RED}ANDROID_SDK_ROOT${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_SDK_ROOT${COLOR_OFF}, ${COLOR_GREEN}$ANDROID_SDK_ROOT/ndk-bundle${COLOR_OFF}, which is used as the android ndk home."
            export ANDROID_NDK_HOME="$ANDROID_SDK_ROOT/ndk-bundle"
        else
            echo "you have set the ${COLOR_RED}ANDROID_SDK_ROOT${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_SDK_ROOT${COLOR_OFF}, ${COLOR_GREEN}$ANDROID_SDK_ROOT/ndk-bundle${COLOR_OFF} direcotory is not exist."
        fi
    fi

    echo

    if [ -z "$ANDROID_NDK_HOME" ] ; then
        die "please set and export ANDROID_NDK_HOME=DIR environment variable, then try again!"
    fi
    
    TOOLCHAIN_NAME='android-ndk'
    TOOLCHAIN_ROOT="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/$NATIVE_OS_KIND-$NATIVE_OS_ARCH"
    TOOLCHAIN_BIN_DIR="$TOOLCHAIN_ROOT/bin"
    SYSROOT="$TOOLCHAIN_ROOT/sysroot"

    ANDROID_NDK_VERSION="$(ndk_version)"
    ANDROID_NDK_VERSION_MAJOR="$(ndk_version_major)"

    # Android NDK version must be r19 or newer.
    if [ "$ANDROID_NDK_VERSION_MAJOR" -lt 19 ] ; then
        die "your installed android-ndk [$ANDROID_NDK_HOME] version is $ANDROID_NDK_VERSION, please update to r19 or newer."
    fi

    TOOLCHAIN_VERSION=$ANDROID_NDK_VERSION

    export PATH="$ANDROID_NDK_HOME:$PATH"
}

inspect_install_arguments() {
    unset ACTION
    ACTION=$1

    shift

    # https://stackoverflow.com/questions/18476490/what-is-purpose-of-target-arch-variable-in-makefiles
    unset TARGET_ARCH

    # https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element#api-level-table
    unset USER_SPECIFIED_TARGET_OS_VERS

    unset USER_SPECIFIED_PACKAGE_LIST

    unset DRYRUN
    unset DEBUG
    unset VERBOSE

    unset NPROC
    unset NJOBS

    unset KEEP_WORKING_DIR

    unset NEED_RUN_TREE
    unset NEED_RUN_PACK

    unset TREE_ARGS
    unset PACK_ARGS
    unset PACK_TYPE

    unset INSTALL_EXE
    unset INSTALL_MAN
    unset INSTALL_DOC
    unset INSTALL_LIB

    unset LINKAGE

    while [ -n "$1" ]
    do
        case "$1" in
            --min-sdk-api-level=[1-9][0-9])
                USER_SPECIFIED_TARGET_OS_VERS=$(getvalue "$1")
                is_integer "$USER_SPECIFIED_TARGET_OS_VERS" || die "--min-sdk-api-level=INTEGER argument's value must be a integer."
                ;;
            --verbose|-v)
                VERBOSE=YES
                ;;
            --debug|-d)
                DEBUG=YES
                ;;
            --xtrace|-x)
                ;;
            --dry-run)
                DRYRUN=YES
                ;;
            --keep-working-dir)
                KEEP_WORKING_DIR=YES
                ;;
            --tree)
                NEED_RUN_TREE=YES
                ;;
            --tree-args=*)
                TREE_ARGS=$(getvalue "$1")
                ;;
            --pack)
                NEED_RUN_PACK=YES
                ;;
            --pack-type=*)
                PACK_TYPE=$(getvalue "$1")
                case $PACK_TYPE in
                    7z|zip|tar.gz|tar.xz|tar.bz2) ;;
                    '') die "--pack-type=VALUE VALUE must not be empty." ;;
                    *) die "--pack-type=VALUE VALUE must be one of 7z zip tar.gz tar.xz tar.bz2."
                esac
                ;;
            --install-doc)
                INSTALL_DOC=YES
                ;;
            --install-man)
                INSTALL_MAN=YES
                ;;
            --install-exe)
                INSTALL_EXE=YES
                ;;
            --install-lib=*)
                INSTALL_LIB=$(getvalue "$1")
                case $INSTALL_LIB in
                    static|shared|both|yes|no) ;;
                    '') die "--install-lib=VALUE VALUE must not be empty." ;;
                    *) die "--install-lib=VALUE VALUE must be one of static shared both yes no"
                esac
                ;;
            --linkage=*)
                LINKAGE=$(getvalue "$1")
                case $LINKAGE in
                    static-only|shared-only|static-prefered|shared-prefered) ;;
                    '') die "--linkage=VALUE VALUE must not be empty." ;;
                    *) die "--linkage=VALUE VALUE must be one of static-only shared-only static-prefered shared-prefered"
                esac
                ;;
            --jobs=*)
                NJOBS=$(getvalue "$1")
                is_integer "$NJOBS" || die "--jobs=INTEGER argument's value must be a integer."
                ;;
            [a-z]*)
                if [ "$1" = 'all' ] ; then
                    USER_SPECIFIED_PACKAGE_LIST="$(__list_available_packages)"
                else
                    if [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] ; then
                        USER_SPECIFIED_PACKAGE_LIST="$1"
                    else
                        USER_SPECIFIED_PACKAGE_LIST="$USER_SPECIFIED_PACKAGE_LIST $1"
                    fi
                fi
                ;;
            *)  die "unrecognized argument: $1"
        esac
        shift
    done

    NPROC=$(nproc)

    if [ -z "$NJOBS" ] ; then
        NJOBS=$NPROC
    fi

    [ -z "$TREE_ARGS" ] && TREE_ARGS='--dirsfirst'
    [ -z "$PACK_TYPE" ] || PACK_ARGS="--type=$PACK_TYPE"

    BUILD_LIST="$(__list_supported_target_abis)"

    unset COMMON_INCLUDE_H_FILEPATH
    COMMON_INCLUDE_H_FILEPATH="$MY_HOME_DIR/include.h"
    if [ ! -f "$COMMON_INCLUDE_H_FILEPATH" ] ; then
        cat > "$COMMON_INCLUDE_H_FILEPATH" <<EOF
// https://linux.die.net/man/3/index
#define rindex(str,ch) strrchr(str,ch)

// https://linux.die.net/man/3/bcmp
#define bcmp(b1,b2,len) memcmp(b1,b2,len)

// https://linux.die.net/man/2/wait3
#define wait3(status,options,rusage) waitpid(-1,status,options)

// https://stackoverflow.com/questions/32826175/ftello-and-fseeko-android-build-errors
// https://linux.die.net/man/3/ftello
// int   fseeko(FILE* __fp, off_t __offset, int __whence) __RENAME(fseeko64) __INTRODUCED_IN(24);
// off_t ftello(FILE* __fp) __RENAME(ftello64) __INTRODUCED_IN(24);
#if __ANDROID_API__ < 24
    #define ftello(f) ftell(f)
    #define fseeko    fseek
#endif
EOF
    fi
}

init() {
    # MY represents this software's
    if [ -n "$NDK_PKG_HOME_DIR" ] && [ -d "$NDK_PKG_HOME_DIR" ] ; then
        MY_HOME_DIR="$NDK_PKG_HOME_DIR"
    else
        MY_HOME_DIR="$HOME/.ndk-pkg"
    fi

    MY_ENV_FILEPATH="$MY_HOME_DIR/env"

    if [ -e "$MY_ENV_FILEPATH" ] ; then
        . "$MY_ENV_FILEPATH" || return 1
    fi

    MY_VERSION=0.1.5
    MY_HOME_PAGE="https://github.com/leleliu008/ndk-pkg"
    MY_OFFICAL_FORMULA_REPO_URL="https://github.com/leleliu008/ndk-pkg-formula-repository.git"
    MY_UPGRAGE_URL='https://raw.githubusercontent.com/leleliu008/ndk-pkg/master/bin/ndk-pkg'
    MY_ZSH_COMPLETION_SCRIPT_URL='https://raw.githubusercontent.com/leleliu008/ndk-pkg/master/zsh-completion/_ndk-pkg'

    MY_FORMULA_REPO_DIR="$MY_HOME_DIR/repos.d"
    MY_INSTALL_DIR="$MY_HOME_DIR/install.d"
    MY_SOURCE_DIR="$MY_HOME_DIR/source.d"
    MY_BINARY_DIR="$MY_HOME_DIR/binary.d"
    MY_BACKUP_DIR="$MY_HOME_DIR/backup.d"
    MY_PATCH__DIR="$MY_HOME_DIR/patch.d"

    if [ ! -e "$MY_HOME_DIR/repos" ] ; then
        install -d "$MY_HOME_DIR"
        echo "offical=$MY_OFFICAL_FORMULA_REPO_URL"  > "$MY_HOME_DIR/repos"
    fi

    if command -v date > /dev/null ; then
        TIMESTAMP_UNIX="$(date +%s)"
    else
        die "command not found: date. please make sure it in PATH."
    fi

    if command -v uname > /dev/null ; then
        unset NATIVE_OS_KIND
        unset NATIVE_OS_TYPE
        unset NATIVE_OS_NAME
        unset NATIVE_OS_VERS
        unset NATIVE_OS_ARCH
        unset NATIVE_OS_LIBC
        unset NATIVE_OS_SUBS

        NATIVE_OS_KIND=$(os kind)
        NATIVE_OS_TYPE=$(os type)
        NATIVE_OS_NAME=$(os name)
        NATIVE_OS_VERS=$(os vers)
        NATIVE_OS_ARCH=$(os arch)
        NATIVE_OS_LIBC=$(os libc)
        NATIVE_OS_SUBS=$(os subs)
    else
        die "command not found: uname. please make sure it in PATH."
    fi
}

help() {
    cat << EOF
$CURRENT_SCRIPT_FILENAME ($MY_VERSION) is a package manager for Android NDK to build C/C++ project.

Usage: $CURRENT_SCRIPT_FILENAME <ACTION> [ARGUMENT...]

ACTION:
    --help    | -h                --show the help information of this command.

    --version | -V                --print the version of this command.

    env                           --show current machine os and android-ndk toolchain info.

    integrate zsh [-x | --china]        --download a zsh-completion script file to a approprivate location.

    update                        --update the formula repositories.

    cleanup                       --cleanup the unused cache.

    target levels                 --list the supported target os's api-levels.

    target triples                --list the supported target triples.

    target archs                  --list the supported target archs.

    target abis                   --list the supported target abis.
    
    ls-available                  --list the available packages.

    ls-installed                  --list the installed packages.

    ls-outdated                   --list the outdated  packages.

    is-available PACKAGE [eq|ne|ge|gt|le|lt VERSION]          --is PACKAGE available?

    is-installed PACKAGE          --is PACKAGE installed?

    is-outdated  PACKAGE          --is PACKAGE outdated?

    search KEYWORD                --search available packages.
    
    formula create PACKAGE        --create a new formula.

    formula delete PACKAGE        --delete a exist formula.

    formula rename P1 P2          --rename a exist formula to new name.

    formula view PACKAGE          --view the formula of the given package.

    formula edit PACKAGE          --edit the formula of the given package.

    formula list                  --list all formulas.

    formula-repo [list]           --list formula-repos.

    formula-repo add  NAME URL    --add a new formula-repo.

    formula-repo del  NAME        --delete a exist formula-repo.

    tree PACKAGE [-L N]           --list files of the given installed package in a tree-like format.

    pack PACKAGE                  --pack the given installed package.

    logs PACKAGE ABI              --show logs of the given installed package.

    info PACKAGE [KEY|--json]            --print the information of the given package.

    info @all [--json]            --print the information of all the available packages.

    fetch PACKAGE                 --download formula resources of the given package to the cache.

    prefix [PACKAGE]              --show the installation direcotory of the given package or the home directory of this software.

    depends PACKAGE               --show the depends of the given package.

    homepage open [PACKAGE]       --show or open the homepage of the given package or this project in web browser.

    install   PACKAGE... [--min-sdk-api-level=21 --jobs=N -v -x --dry-run --keep-working-dir]     --install packages.

    reinstall PACKAGE... [--min-sdk-api-level=21 --jobs=N -v -x --dry-run --keep-working-dir]     --reinstall packages.

    upgrade   PACKAGE... [--min-sdk-api-level=21 --jobs=N -v -x --dry-run --keep-working-dir]     --upgrade packages.

    upgrade @self  [-x | --china]   --upgrade this software.

    uninstall PACKAGE...          --uninstall packages.
EOF
    if [ -z "$1" ] ; then
        exit
    else
        exit "$1"
    fi
}

main() {
    unset XTRACE

    for arg in $@
    do
        case $arg in
            --xtrace|-x)
                XTRACE=YES
                set -x
                break
                ;;
        esac
    done

    init

    case $1 in
        ''|--help|-h) 
            help
            ;;
        --version|-V)
            echo "$MY_VERSION"
            ;;
        env)
            echo "ndk-pkg ($MY_VERSION) is a package manager for Android NDK to build C/C++/Rust/Go project."
            echo
            run os
            echo
            run "id | tr ' ' '\n'"
            echo
            run env
            echo
            run export -p

            inspect_build_toolchains

            echo "$TOOLCHAIN_NAME $TOOLCHAIN_VERSION"
            ;;
        target)
            shift
            case $1 in
                levels)  shift; __list_supported_target_sdk_api_levels ;;
                triples) shift; __list_supported_target_triples ;;
                archs)   shift; __list_supported_target_archs ;;
                abis)    shift; __list_supported_target_abis ;;
                *) help 1
            esac
            ;;
        ls-available) shift; __list_available_packages ;;
        ls-installed) shift; __list_installed_packages ;;
        ls-outdated)  shift; __list__outdated_packages ;;

        is-available) shift; is_package_available $@ ;;
        is-installed) shift; is_package_installed $@ ;;
        is-outdated)  shift; is_package__outdated $@ ;;

        formula-repo)
            shift
            case $1 in
                list) shift; __list_formula_repositories ;;
                add)  shift; __add_a_formula_repo $@ ;;
                del)  shift; __del_a_formula_repo $@ ;;
                *) help 1
            esac
            ;;
        formula)
            shift
            case $1 in
                create) shift; __create_formula_of_the_given_package $@ ;;
                delete) shift; __delete_formula_of_the_given_package $@ ;;
                rename) shift; __rename_formula_of_the_given_package $@ ;;
                view)   shift;   __view_formula_of_the_given_package $@ ;;
                edit)   shift;   __edit_formula_of_the_given_package $@ ;;
                list)   shift; __list_formulas ;;
                   *)   help 1
            esac
            ;;
        update)  __update_formula_repositories ;;
        cleanup) __cleanup ;;

        search)  shift; __search_packages "$*" ;;

        install)   __install_the_given_packages $@ ;;
      reinstall) __reinstall_the_given_packages $@ ;;
      uninstall) __uninstall_the_given_packages $@ ;;

        upgrade)
            shift
            case $1 in
                @self)
                    shift
                    __upgrade_self "$MY_UPGRAGE_URL" $@ ;;
                *)  __upgrade_packages $@ ;;
                esac
            ;;
        integrate)
            shift
            case $1 in
                zsh)
                    shift
                    __integrate_zsh_completions "$MY_ZSH_COMPLETION_SCRIPT_URL" $@
                    ;;
                *)  die "ndk-pkg integrate $1: not support."
            esac
            ;;
        homepage) shift; __show_or_open_homepage_of_the_given_package $@ ;;
        depends)  shift; __show_depends_of_the_given_package    $@ ;;
        prefix)   shift; __show_prefix     $@ ;;
        fetch)    shift; __load_formula_of_the_given_package $@ &&
                         __fetch_resources_of_the_given_package "$@" ;;

        logs) shift; __logs_the_given_installed_package $@ ;;
        pack) shift; __pack_the_given_installed_package $@ ;;
        tree) shift; __tree_the_given_installed_package $@ ;;

        info)
            shift
            case $1 in
                @all) __show_infomation_of_all_available_packages $@ ;;
                *)    __show_infomation_of_the_given_package $@ ;;
            esac
            ;;

        ldd)shift; __ldd $@ ;;

        list-dynamic-library-names)
            shift; list_dynamic_library_names_of_the_given_package $@ ;;
        gen-github-workflows)
            shift; __gen_github_workflows $@ ;;

        install-android-ndk)
            shift
            install_android_ndk $@
            ;;
        test)
            handle_dependency required exe cmake ge 3.10
            ;;
        *) help 1
    esac
}

main $@
